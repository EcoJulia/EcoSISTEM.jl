var documenterSearchIndex = {"docs":
[{"location":"basics/#The-basics-of-EcoSISTEM.jl","page":"Basics","title":"The basics of EcoSISTEM.jl","text":"","category":"section"},{"location":"basics/#Install","page":"Basics","title":"Install","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"Simulation has yet to be officially released, but you can download the package through github:","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"]add https://github.com/boydorr/EcoSISTEM.jl.git","category":"page"},{"location":"basics/#Setting-up-an-ecosystem","page":"Basics","title":"Setting up an ecosystem","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"The package runs on an Ecosystem containing information about species, the SpeciesList, their environment, AbioticEnvironment and the relationship between the two, TraitRelationship.","category":"page"},{"location":"basics/#A-simple-example","page":"Basics","title":"A simple example","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"Load required packages","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"using EcoSISTEM\nusing EcoSISTEM.Units\nusing Unitful, Unitful.DefaultSymbols\nusing Distributions\nusing Diversity","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Set up initial parameters for ecosystem","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"numSpecies = 10; grid = (5, 5); req= 10.0kJ; individuals=1000; area = 1000.0*km^2; totalK = 1.0kJ/km^2","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Set up how much energy each species consumes","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"energy_vec = SolarRequirement(fill(req, numSpecies))","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Set rates for birth and death","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"birth = 0.6/year\ndeath = 0.6/year\nlongevity = 1.0\nsurvival = 0.2\nboost = 1.0\n# Collect model parameters together\nparam = EqualPop(birth, death, longevity, survival, boost)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Create kernel for movement","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"kernel = fill(GaussianKernel(10.0km, 10e-10), numSpecies)\nmovement = BirthOnlyMovement(kernel, Torus())","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Create species list, including their temperature preferences, seed abundance and native status","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"opts = fill(274.0K, numSpecies)\nvars = fill(0.5K, numSpecies)\ntraits = GaussTrait(opts, vars)\nnative = fill(true, numSpecies)\n# abun = rand(Multinomial(individuals, numSpecies))\nabun = fill(div(individuals, numSpecies), numSpecies)\nsppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n    movement, param, native)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Create abiotic environment - even grid of one temperature","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"abenv = simplehabitatAE(274.0K, grid, totalK, area)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Set relationship between species and environment (gaussian)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"rel = Gauss{typeof(1.0K)}()","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Create ecosystem","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"eco = Ecosystem(sppl, abenv, rel)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Run simulation","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"# Simulation Parameters\nburnin = 5years; times = 50years; timestep = 1month; record_interval = 3months; repeats = 1\nlensim = length(0years:record_interval:times)\n# Burnin\n@time simulate!(eco, burnin, timestep)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Plot using SpatialEcology","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"using SpatialEcology\nplot(eco)","category":"page"},{"location":"data/#Using-the-data-pipeline","page":"Data","title":"Using the data pipeline","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"This page summarises the basic usage of the data pipeline. For more information see the DataRegistryUtils.jl repository and documentation.","category":"page"},{"location":"data/#Overview","page":"Data","title":"Overview","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"This package uses DataRegistryUtils.jl, which provides a Julia interaction with the SCRC data registry. An overview of the pipeline itself can be found here.","category":"page"},{"location":"data/#Basic-flow","page":"Data","title":"Basic flow","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"The basic flow is as follows:","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"Write a config.yaml file, which specifies the data products which you need.\nDownload the specified data products from the registry.\nFrom within your model script, use the read functions provided by DataRegistryUtils or access directly through the downloaded database. An optional SQL file can be provided to describe how a data product should be displayed.\nWrite model outputs back to pipeline (WIP).","category":"page"},{"location":"data/#Config-file","page":"Data","title":"Config file","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"See examples/Epidemiology/data_config.yaml for an example.","category":"page"},{"location":"data/#Downloading-data","page":"Data","title":"Downloading data","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"Use the download_data_registry function from SimulationData.jl. For example:","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"julia> using DataRegistryUtils\n[ Info: Precompiling DataRegistryUtils [1a5903ec-9658-4297-bb6d-314c615f2e02]\n\njulia> db = fetch_data_per_yaml(\"examples/Epidemiology/data_config.yaml\")\nprocessing config file: examples/Epidemiology/data_config.yaml\n - hint: use the 'verbose' option to see more stuff\n - downloading human/demographics/population/scotland/1.0.1.h5, please wait...\nWARNING - HASH DISCREPANCY DETECTED:\n server file := human/demographics/population/scotland/1.0.1.h5\n hash: 835fa268cb115510d3195b957fe8dd61665e5f6b\n downloaded: ./out/human/demographics/population/scotland/1.0.1.h5\n hash: b238974dd07fbaf4495ba51282f6ad44db486e9a\n - files refreshed, but issues were detected.\nDict{Any,Any} with 7 entries:\n  \"fixed-parameters/T_hos\"                              => Dict{String,Any}(\"T_hos\"=>Dict{String,Any}(\"value\"=>5,\"type\"=>\"point-estim…\n  \"geography/lookup_table/gridcell_admin_area/scotland\" => Dict{Any,Any}(\"/conversiontable/scotland\"=>NamedTuple{(:grid1km_id, :grid1…\n  \"human/demographics/population/scotland\"              => Dict{Any,Any}(\"/travel_to_work_area/age/genders\"=>[87.0 93.0 … 22.0 37.0; …\n  \"fixed-parameters/T_rec\"                              => Dict{String,Any}(\"T_rec\"=>Dict{String,Any}(\"value\"=>11,\"type\"=>\"point-esti…\n  \"human/infection/SARS-CoV-2/*\"                        => Dict{String,Any}(\"symptom-probability\"=>Dict{String,Any}(\"value\"=>0.692,\"t…\n  \"records/pollution\"                                   => Dict{Any,Any}(\"/array\"=>[NaN NaN; NaN NaN; … ; NaN NaN; NaN NaN])\n  \"prob_hosp_and_cfr/data_for_scotland\"                 => Dict{Any,Any}(\"/cfr_byage\"=>NamedTuple{(:p_h, :cfr, :p_d),Tuple{Float64,Fl…\n","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"The above will download the required data to a specified path or an automatic folder if none defined.","category":"page"},{"location":"data/#Reading-data","page":"Data","title":"Reading data","text":"","category":"section"},{"location":"data/","page":"Data","title":"Data","text":"An example of reading a parameter:","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"db[\"human/infection/SARS-CoV-2/*\"][\"symptom-probability\"]","category":"page"},{"location":"data/","page":"Data","title":"Data","text":"More examples can be found on DataRegistryUtils README or examples folder.","category":"page"},{"location":"model_structure/#Model-structure","page":"Model Structure","title":"Model structure","text":"","category":"section"},{"location":"model_structure/","page":"Model Structure","title":"Model Structure","text":"Description of the model as it currently stands.","category":"page"},{"location":"model_structure/#Epidemiology","page":"Model Structure","title":"Epidemiology","text":"","category":"section"},{"location":"model_structure/","page":"Model Structure","title":"Model Structure","text":"We currently have an SEI3HRD compartmental model: Susceptible-Exposed-Asymptomatic-Presymptomatic-Symptomatic-Hospitalised-Recovered-Dead, as seen in Figure 1 below. Each compartment may be broken up into several age categories.","category":"page"},{"location":"model_structure/#Virus-update-loop","page":"Model Structure","title":"Virus update loop","text":"","category":"section"},{"location":"model_structure/","page":"Model Structure","title":"Model Structure","text":"Virus grows as the sum of several Binomial draws from each infection category, NV_k c sim mathrmPoisson(f_c) where NV is new virus, k is the current grid square, c is the disease class, and f_c is the force of infection generation per disease class.\nThe force of infection is dependent on the population size of that disease class (P_ck), the growth parameter of that disease class (g_c): f_c = g_c * P_ck\nThe virus decays similarly, according to a set probability d and the inverse match with environment at that location (T_k^-1): Decayed virus sim mathrmBinomial(V_k d * T_k^-1)\nThe newly generated virus is distributed 'locally' in space (i.e. grid square k rightarrow j) via a Gaussian kernel: D_c(kj)*NV_kc where D_c is a Gaussian kernel per infection class.\nAn optional 'commuting' distribution of the virus is also possible, in addition to the local gaussian spread. Each can be weighted per compartment, and turned off/on through this parameter choice. In lockdown, all commuting movements are turned off.\nCurrently, only the symptomatic and asymptomatic infectious classes can generate and spread virus, and f_c = 0 for all others.\nNewly generated virus infects other susceptible groups either as an instantaneous force of infection (e.g. aerosol transmission) or through environmental transmission (e.g. through contact with a surface), both at separate rates. See below for more details.","category":"page"},{"location":"model_structure/#Disease-class-update-loop","page":"Model Structure","title":"Disease class update loop","text":"","category":"section"},{"location":"model_structure/","page":"Model Structure","title":"Model Structure","text":"Birth/death per class: Susceptibles are born into the population at a set probability per class. There is also a background probability of death from each disease class.\nmathrmBirths_kc sim mathrmBinomial(P_kc b_c)\nmathrmDeaths_kc sim mathrmBinomial(P_kc d_c)\nTransitions per class: transitions between disease classes happen according to a transition matrix M, which are calculated as moves into the disease class from other categories: in_k c = sum_j^J mathrmBinomial(P_k j M_c j) where j in1J number of classes.\nM is constructed in advance and is altered for movement from Susceptible to Exposed categories by the amount of virus available in that location, V_k, or the instantaneous force of infection, F_k, which disappears at the end of each step. Each has its own associated parameter to weight the different types of infection; beta_e and beta_f, respectively.\nYou can optionally decide whether or not to weight the transmission by a separate parameter (set 0 - 1), w, to decide whether aerosol or contact-based transmission is density or frequency dependent:\nEnvironmental reservoir = beta_f * V_k  N^w\nForce of infection = beta_e * F_k  N^w","category":"page"},{"location":"model_structure/","page":"Model Structure","title":"Model Structure","text":"(Image: )","category":"page"},{"location":"model_structure/","page":"Model Structure","title":"Model Structure","text":"Figure 1: Current model structure.","category":"page"},{"location":"model_structure/#Code-Structure","page":"Model Structure","title":"Code Structure","text":"","category":"section"},{"location":"model_structure/","page":"Model Structure","title":"Model Structure","text":"The virus update loop happens first, parallelised over disease category. The virus must move between locations, so each process must have full access to the entire space. This will parallelise better when we have more disease categories, like age.\nThe disease class update loop happens second, parallelised over space. There is no movement between locations, but instead transitions between different categories.\nAn overall matrix housing the abundances per grid square and per disease category is housed in the EpiSystem, along with information on environment and a lookup table of moves between different grid squares for each kernel.\nAt every iteration of the update step, this matrix is updated in place to avoid additional memory allocation.\nMovement of the virus is now deterministic in the first stage of the virus update loop, and then drawn from a Poisson distribution based on this result in the second stage.","category":"page"},{"location":"epi/#Epidemiology","page":"SCRC","title":"Epidemiology","text":"","category":"section"},{"location":"epi/","page":"SCRC","title":"SCRC","text":"Code supporting epidemiological simulations developed during the RAMP period (March - December 2020) was originally found on a separate fork.","category":"page"},{"location":"epi/","page":"SCRC","title":"SCRC","text":"Development on this resource will be slowed down until both code bases can be reintegrated here. See the Scottish Covid Response Consortium for more details of the project.","category":"page"},{"location":"africa/#Virtual-plant-simulations-of-Africa","page":"Africa","title":"Virtual plant simulations of Africa","text":"","category":"section"},{"location":"africa/","page":"Africa","title":"Africa","text":"EcoSISTEM was designed to scale to much larger areas, supporting many more species. As an illustrative example, here we simulate up to 50,000 plant species over Africa at an 80km grid scale, with a constant background environment of 25°C. When all species are given an equal fitness in the habitat, all 50,000 can co-exist over long time scales of over 100 years (Figure 2A). This can be run on a workstation with 24 threads in just under 5 hours.","category":"page"},{"location":"africa/","page":"Africa","title":"Africa","text":"We can also explore the behaviour of selective advantage of specialist species over generalists at these scales. When we introduce a specialist species into an African-sized landscape with an existing generalist, the specialist out-competes the generalist and spreads throughout the continent. The larger the selective advantage of the specialist, the faster it is able to invade and colonise across the landscape (Figure 1). These same dynamics can be seen when we introduce a specialist to the full complement of 50,000 species (Figure 1B-D).","category":"page"},{"location":"africa/#SINGLE-SPECIES","page":"Africa","title":"SINGLE SPECIES","text":"","category":"section"},{"location":"africa/","page":"Africa","title":"Africa","text":"using EcoSISTEM\nusing EcoSISTEM.ClimatePref\nusing EcoSISTEM.Units\nusing Unitful\nusing Unitful.DefaultSymbols\nusing Distances\nusing StatsBase\nusing Plots\nfile = \"Africa.tif\"\nafrica = readfile(file, -25°, 50°, -35°, 40°)\nactive =  Array{Bool, 2}(.!isnan.(africa'))\n\nheatmap(active)\n\n# Set up initial parameters for ecosystem\nnumSpecies = 1; grid = size(africa); req= 10.0kJ; individuals=0; area = 64e6km^2; totalK = 1000.0kJ/km^2\n\n# Set up how much energy each species consumes\nenergy_vec = SolarRequirement(fill(req, numSpecies))\n\n\n# Set rates for birth and death\nbirth = 0.6/year\ndeath = 0.6/year\nlongevity = 1.0\nsurvival = 0.0\nboost = 1.0\n# Collect model parameters together\nparam = EqualPop(birth, death, longevity, survival, boost)\n\n# Create kernel for movement\nkernel = fill(GaussianKernel(15.0km, 10e-10), numSpecies)\nmovement = AlwaysMovement(kernel, Torus())\n\n\n# Create species list, including their temperature preferences, seed abundance and native status\nopts = fill(274.0K, numSpecies)\nvars = fill(0.5K, numSpecies)\ntraits = GaussTrait(opts, vars)\nnative = fill(true, numSpecies)\n# abun = rand(Multinomial(individuals, numSpecies))\nabun = fill(div(individuals, numSpecies), numSpecies)\nsppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n    movement, param, native)\nsppl.params.birth\n\n# Create abiotic environment - even grid of one temperature\nabenv = simplehabitatAE(274.0K, grid, totalK, area, active)\n\n\n# Set relationship between species and environment (gaussian)\nrel = Gauss{typeof(1.0K)}()\n\n#Create ecosystem\neco = Ecosystem(sppl, abenv, rel)\nrand_start = rand(findall(active), 1)[1]\neco.abundances.grid[1, rand_start[1], rand_start[2]] = 100\n\n# Simulation Parameters\ntimes = 100years; timestep = 1month; record_interval = 1month; repeats = 1\nlensim = length(0years:record_interval:times)\nabuns = zeros(Int64, numSpecies, prod(grid), lensim)\n@time simulate_record!(abuns, eco, times, record_interval, timestep);\n\nabuns = reshape(abuns[1, :, :, 1], grid[1], grid[2], lensim)\n\nanim = @animate for i in 1:lensim\n    africa_abun = Float64.(abuns[:, :, i])\n    africa_abun[.!(active)] .= NaN\n    heatmap(africa_abun, clim = (0, 700_000), background_color = :lightblue, background_color_outside=:white, grid = false, color = cgrad(:algae, scale = :exp), aspect_ratio = 1)\nend\ngif(anim, \"examples/Biodiversity/Africa.gif\", fps = 30)\n\n#### SPECIALIST VERSUS GENERALIST ####\n\nspecialist_vars = [0.5K, 1.0K, 5.0K, 10.0K, 25.0K, 50.0K]\nvelocity = zeros(typeof(1.0km/month), length(specialist_vars))\nrand_start = rand(findall(active), 1)[1]\nfor i in eachindex(specialist_vars)\n    # Set up initial parameters for ecosystem\n    numSpecies = 2; grid = size(africa); req= 10.0kJ; individuals=0; area = 64e6km^2; totalK = 1000.0kJ/km^2\n\n    # Set up how much energy each species consumes\n    energy_vec = SolarRequirement(fill(req, numSpecies))\n\n\n    # Set rates for birth and death\n    birth = 0.6/year\n    death = 0.6/year\n    longevity = 1.0\n    survival = 0.1\n    boost = 1.0\n    # Collect model parameters together\n    param = EqualPop(birth, death, longevity, survival, boost)\n\n    # Create kernel for movement\n    kernel = fill(GaussianKernel(15.0km, 10e-10), numSpecies)\n    movement = AlwaysMovement(kernel, Torus())\n\n\n    # Create species list, including their temperature preferences, seed abundance and native status\n    opts = fill(274.0K, numSpecies)\n    vars = [50.0K, specialist_vars[i]]\n    traits = GaussTrait(opts, vars)\n    native = fill(true, numSpecies)\n    # abun = rand(Multinomial(individuals, numSpecies))\n    abun = fill(div(individuals, numSpecies), numSpecies)\n    sppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n        movement, param, native)\n    sppl.params.birth\n\n    # Create abiotic environment - even grid of one temperature\n    abenv = simplehabitatAE(274.0K, grid, totalK, area, active)\n\n    # Set relationship between species and environment (gaussian)\n    rel = Gauss{typeof(1.0K)}()\n\n    #Create ecosystem\n    eco = Ecosystem(sppl, abenv, rel)\n    eco.abundances.grid[1, rand_start[1], rand_start[2]] = 100\n\n    # Simulation Parameters\n    burnin = 100years; times = 100years; timestep = 1month; record_interval = 1month; repeats = 1\n    lensim = length(0years:record_interval:times)\n    simulate!(eco, burnin,timestep)\n    eco.abundances.grid[2, rand_start[1], rand_start[2]] = 100\n    abuns = zeros(Int64, numSpecies, prod(grid), lensim)\n    @time simulate_record!(abuns, eco, times, record_interval, timestep);\n\n    abuns = reshape(abuns[:, :, :, 1], numSpecies, grid[1], grid[2], lensim)\n    origin = [rand_start[1], rand_start[2]]\n    dest = findall(abuns[2, :, :, 1] .> 0)\n    inst_velocity = map(1:lensim) do t\n        dest = findall(abuns[2, :, :, t] .> 0)\n        dists = [euclidean(origin, [dest[i][1], dest[i][2]]) for i in length(dest)] .* getgridsize(eco)\n        return maximum(dists)/month\n    end\n    velocity[i] = mean(inst_velocity)\nend\n\nplot(ustrip.(abs.(specialist_vars .- 50.0K)), ustrip.(velocity),\n    xlab = \"Selective advantage\", ylab = \"Invasion speed (km/month)\",\n    label = \"\", grid = false)","category":"page"},{"location":"africa/","page":"Africa","title":"Africa","text":"(Image: ) Figure 1: Invasive capacity of a specialist plant species versus a generalist. Selective advantage is the difference in niche width between the specialist and generalist, and invasion speed is calculated as the average distance travelled per month by the specialist.","category":"page"},{"location":"africa/#ONE-SPECIALIST-VERSUS-MANY-GENERALISTS","page":"Africa","title":"ONE SPECIALIST VERSUS MANY GENERALISTS","text":"","category":"section"},{"location":"africa/","page":"Africa","title":"Africa","text":"using EcoSISTEM\nusing EcoSISTEM.ClimatePref\nusing EcoSISTEM.Units\nusing Unitful\nusing Unitful.DefaultSymbols\nusing JLD\nusing Printf\nfile = \"Africa.tif\"\nafrica = readfile(file, -25°, 50°, -35°, 40°)\nactive =  Array{Bool, 2}(.!isnan.(africa'))\n# Set up initial parameters for ecosystem\nnumSpecies = 50_000; grid = size(africa); req= 10.0kJ; individuals=3*10^8; area = 64e6km^2; totalK = 1000.0kJ/km^2\n\n# Set up how much energy each species consumes\nenergy_vec = SolarRequirement(fill(req, numSpecies))\n\n\n# Set rates for birth and death\nbirth = 0.6/year\ndeath = 0.6/year\nlongevity = 1.0\nsurvival = 0.1\nboost = 1.0\n# Collect model parameters together\nparam = EqualPop(birth, death, longevity, survival, boost)\n\n# Create kernel for movement\nkernel = fill(GaussianKernel(15.0km, 10e-10), numSpecies)\nmovement = AlwaysMovement(kernel, Torus())\n\n\n# Create species list, including their temperature preferences, seed abundance and native status\nopts = fill(274.0K, numSpecies)\nvars = fill(50.0K, numSpecies)\nvars[50_000] = 0.5K\ntraits = GaussTrait(opts, vars)\nnative = fill(true, numSpecies)\n# abun = rand(Multinomial(individuals, numSpecies))\nabun = fill(div(individuals, numSpecies), numSpecies)\nsppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n    movement, param, native)\nsppl.params.birth\n\n# Create abiotic environment - even grid of one temperature\nabenv = simplehabitatAE(274.0K, grid, totalK, area, active)\n\n\n# Set relationship between species and environment (gaussian)\nrel = Gauss{typeof(1.0K)}()\n\n#Create ecosystem\neco = Ecosystem(sppl, abenv, rel)\neco.abundances.matrix[50_000, :] .= 0\n\nimport EcoSISTEM.simulate!\nfunction simulate!(eco::Ecosystem, times::Unitful.Time, timestep::Unitful.Time, cacheInterval::Unitful.Time, cacheFolder::String, scenario_name::String)\n  time_seq = 0s:timestep:times\n  counting = 0\n  for i in 1:length(time_seq)\n      update!(eco, timestep);\n      # Save cache of abundances\n      if mod(time_seq[i], cacheInterval) == 0year\n          JLD.save(joinpath(cacheFolder, scenario_name * (@sprintf \"%02d.jld\" uconvert(NoUnits,time_seq[i]/cacheInterval))), \"abun\", eco.abundances.matrix)\n      end\n  end\nend\n\n# Simulation Parameters\nburnin = 100years; times = 100years; timestep = 1month; record_interval = 12months;\nlensim = length(0years:record_interval:times)\n@time simulate!(eco, burnin, timestep)\nrand_start = rand(findall(active), 1)[1]\neco.abundances.grid[50_000, rand_start[1], rand_start[2]] = 100\n@time simulate!(eco, times, timestep, record_interval, \"examples/Biodiversity\", \"Africa_run\");","category":"page"},{"location":"africa/#,000-SPECIES-COEXISTING","page":"Africa","title":"50,000 SPECIES COEXISTING","text":"","category":"section"},{"location":"africa/","page":"Africa","title":"Africa","text":"using EcoSISTEM\nusing EcoSISTEM.ClimatePref\nusing EcoSISTEM.Units\nusing Unitful\nusing Unitful.DefaultSymbols\nusing JLD\nusing Printf\n\nfile = \"Africa.tif\"\nafrica = readfile(file, -25°, 50°, -35°, 40°)\nactive =  Array{Bool, 2}(.!isnan.(africa'))\n# Set up initial parameters for ecosystem\nnumSpecies = 50_000; grid = size(africa); req= 10.0kJ; individuals=3*10^8; area = 64e6km^2; totalK = 1000.0kJ/km^2\n\n# Set up how much energy each species consumes\nenergy_vec = SolarRequirement(fill(req, numSpecies))\n\n\n# Set rates for birth and death\nbirth = 0.6/year\ndeath = 0.6/year\nlongevity = 1.0\nsurvival = 0.1\nboost = 1.0\n# Collect model parameters together\nparam = EqualPop(birth, death, longevity, survival, boost)\n\n# Create kernel for movement\nkernel = fill(GaussianKernel(15.0km, 10e-10), numSpecies)\nmovement = AlwaysMovement(kernel, Torus())\n\n\n# Create species list, including their temperature preferences, seed abundance and native status\nopts = fill(274.0K, numSpecies)\nvars = fill(50.0K, numSpecies)\ntraits = GaussTrait(opts, vars)\nnative = fill(true, numSpecies)\n# abun = rand(Multinomial(individuals, numSpecies))\nabun = fill(div(individuals, numSpecies), numSpecies)\nsppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n    movement, param, native)\nsppl.params.birth\n\n# Create abiotic environment - even grid of one temperature\nabenv = simplehabitatAE(274.0K, grid, totalK, area, active)\n\n\n# Set relationship between species and environment (gaussian)\nrel = Gauss{typeof(1.0K)}()\n\n#Create ecosystem\neco = Ecosystem(sppl, abenv, rel)\n\n# Simulation Parameters\nburnin = 10years; times = 100years; timestep = 1month; record_interval = 12months;\nlensim = length(0years:record_interval:times)\n@time simulate!(eco, burnin, timestep)\n@time simulate!(eco, times, timestep, record_interval, \"examples/Biodiversity\", \"Africa_run_coexist\");\n\nusing JLD\nusing Plots\nusing Diversity\nabuns = load(\"examples/Biodiversity/Africa_run_coexist100.jld\", \"abun\")\nmeta = Metacommunity(abuns)\ndiv = norm_sub_alpha(meta, 0)\nsumabuns = reshape(div[!, :diversity], 100, 100)\nheatmap(sumabuns,\n    background_color = :lightblue,\n    background_color_outside=:white,\n    grid = false, color = :algae,\n    aspect_ratio = 1, layout = (@layout [a b; c d]),\n    clim = (0, 50_000), margin = 0.5 * Plots.mm,\n    title = \"A\", titleloc = :left)\n\nabuns = load(\"examples/Biodiversity/Africa_run50.jld\", \"abun\")\nmeta = Metacommunity(abuns)\ndiv = norm_sub_alpha(meta, 0)\nsumabuns = reshape(div[!, :diversity], 100, 100)\nheatmap!(sumabuns,\n    background_color = :lightblue,\n    background_color_outside=:white,\n    grid = false, color = :algae,\n    aspect_ratio = 1, subplot = 2,\n    clim = (0, 50_000), right_margin = 2.0 * Plots.mm,\n    title = \"B\", titleloc = :left)\n\nabuns = load(\"examples/Biodiversity/Africa_run100.jld\", \"abun\")\nmeta = Metacommunity(abuns)\ndiv = norm_sub_alpha(meta, 0)\nsumabuns = reshape(div[!, :diversity], 100, 100)\nheatmap!(sumabuns,\n    background_color = :lightblue,\n    background_color_outside=:white,\n    grid = false, color = :algae,\n    aspect_ratio = 1, subplot = 3,\n    clim = (0, 50_000), right_margin = 2.0 * Plots.mm,\n    title = \"C\", titleloc = :left)\n\n\nabuns = load(\"examples/Biodiversity/Africa_run50.jld\", \"abun\")\nmeta = Metacommunity(abuns)\ndiv = norm_sub_rho(meta, 1.0)\nsumabuns = reshape(div[!, :diversity], 100, 100)\nheatmap!(sumabuns,\n    background_color = :lightblue,\n    background_color_outside=:white,\n    grid = false, color = :algae,\n    aspect_ratio = 1, subplot = 4,\n     right_margin = 2.0 * Plots.mm,\n    title = \"D\", titleloc = :left, clim = (0, 1))","category":"page"},{"location":"africa/","page":"Africa","title":"Africa","text":"(Image: ) Figure 2: 100 year simulations of Africa with 50,000 species. (A) Species richness after 100 years of simulation with all species equal. (B) Species richness after 50 years, with one specialist introduced. (C) Species richness after 100 years, with one specialist introduced. (D) Representativeness after 50 years with one specialist introduced (0 is completely unrepresentative of the ecosystem as a whole, 1 is completely representative).","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [EcoSISTEM]\nPrivate = true","category":"page"},{"location":"api/#EcoSISTEM.AbstractAbiotic","page":"API","title":"EcoSISTEM.AbstractAbiotic","text":"AbstractAbiotic{H <: AbstractHabitat, B <: AbstractBudget} <: AbstractPartition\n\nAbstract supertype for all abiotic environment types and a subtype of AbstractPartition\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractBudget","page":"API","title":"EcoSISTEM.AbstractBudget","text":"AbstractBudget\n\nAbstract supertype for all budget types\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractControl","page":"API","title":"EcoSISTEM.AbstractControl","text":"AbstractControl\n\nAbstract type for all control strategies.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractEcosystem","page":"API","title":"EcoSISTEM.AbstractEcosystem","text":"AbstractEcosystem{Part <: AbstractAbiotic, SL <: SpeciesList,\n    TR <: AbstractTraitRelationship} <: AbstractMetacommunity{Float64,\n        Matrix{Int64}, Matrix{Float64}, SL, Part}\n\nAbstract supertype for all ecosystem types and a subtype of AbstractMetacommunity.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractEpiEnv","page":"API","title":"EcoSISTEM.AbstractEpiEnv","text":"AbstractEpiEnv{H <: AbstractHabitat, C <: AbstractControl} <:\nAbstractPartition{H}\n\nAbstract supertype for all epi environment types and a subtype of AbstractPartition.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractEpiSystem","page":"API","title":"EcoSISTEM.AbstractEpiSystem","text":"AbstractEpiSystem\n\nAbstract supertype for all disease system types.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractHabitat","page":"API","title":"EcoSISTEM.AbstractHabitat","text":"AbstractHabitat\n\nAbstract supertype for all habitat types\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractMovement","page":"API","title":"EcoSISTEM.AbstractMovement","text":"AbstractMovement\n\nAbstract supertype of movements\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractParams","page":"API","title":"EcoSISTEM.AbstractParams","text":"AbstractParams\n\nAbstract supertype for all simulation parameter types\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractRequirement","page":"API","title":"EcoSISTEM.AbstractRequirement","text":"Abstract1Requirement{Energy}\n\nAbstract supertype for all species energy requirement types, parameterised by the type(s) of energy required Energy.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractScenario","page":"API","title":"EcoSISTEM.AbstractScenario","text":"AbstractScenario\n\nAbstract supertype for all whole ecosystem change scenarios\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractTraitRelationship","page":"API","title":"EcoSISTEM.AbstractTraitRelationship","text":"AbstractTraitRelationship{TR}\n\nThe abstract supertype of relationships between a trait and its environment, parameterised on any TR.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractTraits","page":"API","title":"EcoSISTEM.AbstractTraits","text":"AbstractTraits{T}\n\nAbstract supertype for all trait types, parameterised by traits of any type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AlwaysMovement","page":"API","title":"EcoSISTEM.AlwaysMovement","text":"AlwaysMovement{K <: AbstractKernel, B <: BoundaryCondition} <: AbstractMovement\n\nMovement can happen to any individual (\"animal-like\").\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.BirthOnlyMovement","page":"API","title":"EcoSISTEM.BirthOnlyMovement","text":"BirthOnlyMovement{K <: AbstractKernel, B <: BoundaryCondition} <: AbstractMovement\n\nMovement can only happen to individuals that have just been born (\"plant-like\").\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.BoundaryCondition","page":"API","title":"EcoSISTEM.BoundaryCondition","text":"BoundaryCondition\n\nAn abstract type for what should happen at the boundaries of an ecosystem.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Cache","page":"API","title":"EcoSISTEM.Cache","text":"Cache\n\nCache houses an integer array of moves made by all species in a timestep for the update! function, netmigration.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.CachedEcosystem","page":"API","title":"EcoSISTEM.CachedEcosystem","text":"CachedEcosystem{Part <: AbstractAbiotic, SL <: SpeciesList,\n    TR <: AbstractTraitRelationship} <: AbstractEcosystem{Part, SL, TR}\n\nCachedEcosystem houses the same information as Ecosystem (see ?Ecosystem), but holds the time period abundances as a CachedGridLandscape, so that they may be present or missing.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.CachedEcosystem-Tuple{Ecosystem, String, StepRangeLen}","page":"API","title":"EcoSISTEM.CachedEcosystem","text":"CachedEcosystem(eco::Ecosystem, outputfile::String, rng::StepRangeLen)\n\nFunction to create a CachedEcosystem given an existing ecosystem, eco, output folder to which the simulations are saved, outputfile, and a range of times over which to simulate, rng.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.CachedGridLandscape","page":"API","title":"EcoSISTEM.CachedGridLandscape","text":"CachedGridLandscape\n\nEcosystem abundances housed in the cached landscape. These are either stored in the matrix or output to a cache.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.ContinuousHab","page":"API","title":"EcoSISTEM.ContinuousHab","text":"ContinuousHab{C <: Number} <: AbstractHabitat{C}\n\nThis habitat subtype houses a habitat matrix matrix of any units, a grid square size size and HabitatUpdate type change.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.ContinuousTimeHab","page":"API","title":"EcoSISTEM.ContinuousTimeHab","text":"ContinuousTimeHab{C <: Number, M <: AbstractArray{C, 3}} <: AbstractHabitat{C}\n\nThis habitat subtype houses a habitat matrix matrix of any units, the time slice of the habitat matrix currently being operated on time, a grid square size size and HabitatUpdate type change.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.ContinuousTrait","page":"API","title":"EcoSISTEM.ContinuousTrait","text":"ContinuousTrait{C <: Number} <: AbstractTraits{T}\n\nAbstract trait type that holds information on a single continuous trait for each species, of any Number type C.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Cylinder","page":"API","title":"EcoSISTEM.Cylinder","text":"Cylinder <: BoundaryCondition\n\nA cylindrical boundary where species can cross the x boundary but not the y.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.DiscreteHab","page":"API","title":"EcoSISTEM.DiscreteHab","text":"DiscreteHab <: AbstractHabitat{String}\n\nThis habitat subtype has a matrix of strings and a float grid square size\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.DiscreteTrait","page":"API","title":"EcoSISTEM.DiscreteTrait","text":"BasicTrait{T} <: AbstractTraits{T}\n\nBasic trait type that holds information on a single trait for each species, of any type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.DiseaseState","page":"API","title":"EcoSISTEM.DiseaseState","text":"enum: DiseaseState\n\nDisease state of a group, from: Susceptible Infectious Removed OtherDiseaseState\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Ecosystem","page":"API","title":"EcoSISTEM.Ecosystem","text":"Ecosystem{Part <: AbstractAbiotic} <:\n   AbstractEcosystem{Part, SL, TR}\n\nEcosystem houses information on species and their interaction with their environment. For species, it holds abundances and locations, abundances, as well as properties such as trait information, spplist, and movement types, lookup. For environments, it provides information on environmental conditions and available resources,abenv. Finally, there is a slot for the relationship between the environment and the characteristics of the species, relationship.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Ecosystem-Union{Tuple{Req}, Tuple{T}, Tuple{F}, Tuple{F, SpeciesList{T, Req, MO, T1, P} where {MO<:EcoSISTEM.AbstractMovement, T1<:Diversity.API.AbstractTypes, P<:EcoSISTEM.AbstractParams}, GridAbioticEnv, EcoSISTEM.AbstractTraitRelationship}} where {F<:Function, T, Req}","page":"API","title":"EcoSISTEM.Ecosystem","text":"Ecosystem(spplist::SpeciesList, abenv::GridAbioticEnv,\n    rel::AbstractTraitRelationship)\n\nFunction to create an Ecosystem given a species list, an abiotic environment and trait relationship. An optional population function can be added, popfun, which defaults to generic random filling of the ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.EpiLandscape","page":"API","title":"EcoSISTEM.EpiLandscape","text":"EpiLandscape\n\nDisease class abundances housed in the landscape. These are represented in both 2 dimensions (for computational efficiency in simulations) and 3 dimensions (to represent disease classes, their abundances and position in the grid).\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.EpiList","page":"API","title":"EcoSISTEM.EpiList","text":"EpiList{P <: AbstractParams} <: AbstractTypes\n\nEpi list houses all disease and virus class specific information, as well as parameters for model runs.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.EpiList-Union{Tuple{MO}, Tuple{TR}, Tuple{TR, DataFrames.DataFrame, DataFrames.DataFrame, MO, DataFrames.DataFrame, NamedTuple}, Tuple{TR, DataFrames.DataFrame, DataFrames.DataFrame, MO, DataFrames.DataFrame, NamedTuple, Int64}, Tuple{TR, DataFrames.DataFrame, DataFrames.DataFrame, MO, DataFrames.DataFrame, NamedTuple, Int64, NamedTuple}} where {TR<:EcoSISTEM.AbstractTraits, MO<:EcoSISTEM.AbstractMovement}","page":"API","title":"EcoSISTEM.EpiList","text":"EpiList(traits::TR, virus_abun::DataFrame, human_abun::DataFrame,\n             movement::MO, transitions::DataFrame, params::NamedTuple,\n             age_categories::Int64 = 1, movement_balance::NamedTuple = (home = fill(1.0, nrow(human_abun) * age_categories), work = fill(0.0, nrow(human_abun) * age_categories))) where {TR <: AbstractTraits, MO <: AbstractMovement}\n\nFunction to create an EpiList for any type of epidemiological model - creating the correct number of classes and checking dimensions.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.EpiMovement","page":"API","title":"EcoSISTEM.EpiMovement","text":"EpiMovement{MO <: AbstractMovement} <: AbstractMovement\n\nMovement can happen at several different levels, local gaussian processes, home, and longer distance commutes, work.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.EpiParams","page":"API","title":"EcoSISTEM.EpiParams","text":"EpiParams{U <: Unitful.Units} <: AbstractParams\n\nParameter set for any epi model type, which stores information on birth, virus generation and decay probabilities, as well as matrices for transitions between different states. transition houses straightforward transition probabilities between classes, whereas transition_virus houses probabilities that should be multiplied by the amount of virus in the system, such as infection transitions.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.EpiSystem","page":"API","title":"EcoSISTEM.EpiSystem","text":"EpiSystem{EE <: AbstractEpiEnv, EL <: EpiList, ER <: AbstractRelationship} <: AbstractEpiSystem{EE, EL, ER}\n\nEpiSystem houses information on different disease classes, epilist, the environment, epienv, and their relationship to one another, relationship.\n\nSee help?>plot_epidynamics and help?>plot_epiheatmaps for relevant plotting functions.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.EqualPop","page":"API","title":"EcoSISTEM.EqualPop","text":"EqualPop <: AbstractParams\n\nParameter type that holds information on a population's birth and death rates, birth and death, specifically populations where all species have the same information. l represents the longevity of species based on their energy requirements and s is the survival of species dependent on how well their traits reflect the environment. Finally boost is used to manipulate how much of a boost the species get from being in an environment with lots of available energy.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.FluctScenario","page":"API","title":"EcoSISTEM.FluctScenario","text":"FluctScenario <: AbstractScenario\n\nThis scenario type holds a function that acts to fluctuate the environment.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Gauss","page":"API","title":"EcoSISTEM.Gauss","text":"Gauss{TR} <: AbstractTraitRelationship{TR}\n\nThe Gaussian relationship between a continuous trait and its environment, paramaterised on any TR.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.GaussTrait","page":"API","title":"EcoSISTEM.GaussTrait","text":"GaussTrait{C <: Number} <: ContinuousTrait{C}\n\nTrait type that holds Gaussian mean and variance trait information for each species, of any number type C.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.GaussianKernel","page":"API","title":"EcoSISTEM.GaussianKernel","text":"GaussianKernel <: AbstractKernel\n\nGaussianMovement holds parameters for a gaussian movement kernel; a dispersal variance for a species, var, and a threshold, thresh, beyond which dispersal cannot take place.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.GridAbioticEnv","page":"API","title":"EcoSISTEM.GridAbioticEnv","text":"GridAbioticEnv{H, B} <: AbstractAbiotic{H, B}\n\nThis abiotic environment type holds a habitat and budget, as well as a string of subcommunity names.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.GridEpiEnv","page":"API","title":"EcoSISTEM.GridEpiEnv","text":"GridEpiEnv{H, C} <: AbstractAbiotic{H, C}\n\nThis epi environment type holds a habitat and control strategy, as well as a string of subcommunity names, and initial susceptible population.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.GridLandscape","page":"API","title":"EcoSISTEM.GridLandscape","text":"GridLandscape\n\nEcosystem abundances housed in the landscape. These are represented in both 2 dimensions (for computational efficiency in simulations) and 3 dimensions (to represent species, their abundances and position in the grid).\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.HumanTypes","page":"API","title":"EcoSISTEM.HumanTypes","text":"HumanTypes{MO <: AbstractMovement,\n             T <: AbstractTypes} <: AbstractTypes\n\nHumanTypes holds information on the human disease classes, such as the name of each class, their initial abundances and types, as well as how they disperse virus across the landscape.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Lockdown","page":"API","title":"EcoSISTEM.Lockdown","text":"Lockdown <: AbstractControl\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.LongTailKernel","page":"API","title":"EcoSISTEM.LongTailKernel","text":"LongTailKernel <: AbstractKernel\n\nLongTailKernel holds parameters for a movement kernel; a dispersal variance for a species, var, and a threshold, thresh, beyond which dispersal cannot take place.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Lookup","page":"API","title":"EcoSISTEM.Lookup","text":"Lookup\n\nLookup houses information on x, y grid locations and the probability of occurrence at the location for the species in question p. pnew and moves are initially empty storage and written over by the movement step in update!(). pnew is the recalculated probability based on which directions are available and moves is the number of moves to that grid location in that step.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Match","page":"API","title":"EcoSISTEM.Match","text":"Match{TR} <: AbstractTraitRelationship{TR}\n\nThe relationship between a discrete trait and its environment, paramaterised on any TR. Current conditions are matched to a trait preference and checked for a match.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.MultiScenario","page":"API","title":"EcoSISTEM.MultiScenario","text":"MultiScenario{S1 <: AbstractScenario, S2 <: AbstractScenario} <: AbstractScenario\n\nThis scenario type holds multiple different scenario types.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.NoBoundary","page":"API","title":"EcoSISTEM.NoBoundary","text":"NoBoundary <: BoundaryCondition\n\nA hard boundary where no species can cross.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.NoControl","page":"API","title":"EcoSISTEM.NoControl","text":"NoControl <: AbstractControl\n\nDefault strategy, which implements no control measures.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.NoMovement","page":"API","title":"EcoSISTEM.NoMovement","text":"NoMovement{K <: AbstractKernel, B <: BoundaryCondition} <: AbstractMovement\n\nNo movement can take place.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.NoRelContinuous","page":"API","title":"EcoSISTEM.NoRelContinuous","text":"NoRelContinuous{TR} <: AbstractTraitRelationship{TR}\n\nThe absense of a relationship between a continuous trait and its environment, paramaterised on any TR. Returns the value 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.NoRelDiscrete","page":"API","title":"EcoSISTEM.NoRelDiscrete","text":"NoRelDiscrete{TR} <: AbstractTraitRelationship{TR}\n\nThe absense of a relationship between a discrete trait and its environment, paramaterised on any TR. Returns the value 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.PopGrowth","page":"API","title":"EcoSISTEM.PopGrowth","text":"PopGrowth <: AbstractParams\n\nBasic parameter type that holds information on a population's birth and death rates, birth and death, as well as how these are altered by energy availability. l represents the longevity of species based on their energy requirements and s is the survival of species dependent on how well their traits reflect the environment.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.RainBin","page":"API","title":"EcoSISTEM.RainBin","text":"RainBin{C <: Int} <: ContinuousTrait{C}\n\nTrait type that holds binned rainfall preference information created through ClimatePref. Holds an array of counts per rainfall band (mm).\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.SimpleBudget","page":"API","title":"EcoSISTEM.SimpleBudget","text":"SimpleBudget <: AbstractBudget{Float64}\n\nThis budget type has a matrix of floats, representing the energy budget of each subcommunity in the abiotic environment.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.SimpleRequirement","page":"API","title":"EcoSISTEM.SimpleRequirement","text":"SimpleRequirement <: Abstract1Requirement{Float64}\n\nA simple energy requirement is a single float for each species.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.SimpleScenario","page":"API","title":"EcoSISTEM.SimpleScenario","text":"SimpleScenario <: AbstractScenario\n\nThis scenario type holds a function that acts to change the entire ecosystem.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.SizeRequirement","page":"API","title":"EcoSISTEM.SizeRequirement","text":"SizeRequirement <: Abstract1Requirement{Float64}\n\nA simple energy requirement is a single float for each species.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.SolarBudget","page":"API","title":"EcoSISTEM.SolarBudget","text":"SolarBudget <: AbstractBudget{typeof(1.0*kJ)}\n\nThis budget type has a matrix of solar energy units, representing the energy budget of each subcommunity in the abiotic environment at a fixed point in time.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.SolarRequirement","page":"API","title":"EcoSISTEM.SolarRequirement","text":"SolarRequirement <: Abstract1Requirement{typeof(1.0*kJ)}\n\nA vector of solar energy requirements (kJ) for each species.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.SolarTimeBudget","page":"API","title":"EcoSISTEM.SolarTimeBudget","text":"SolarTimeBudget <: AbstractBudget{typeof(1.0*kJ)}\n\nThis budget type has a matrix of solar energy units, representing the energy budget of each subcommunity in the abiotic environment along with which time dimension we are interested in.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.SpeciesList","page":"API","title":"EcoSISTEM.SpeciesList","text":"SpeciesList{TR <: AbstractTraits, R <: AbstractRequirement,\n            MO <: AbstractMovement, T <: AbstractTypes,\n            P <: AbstractParams} <: AbstractTypes\n\nSpecies list houses all species-specific information including trait information, phylogenetic relationships, requirement for energy and movement types.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.SpeciesList-Union{Tuple{P}, Tuple{MO}, Tuple{R}, Tuple{Int64, Int64, Vector{Int64}, R, MO, P, Vector{Bool}, Vector{Float64}}} where {R<:EcoSISTEM.AbstractRequirement, MO<:EcoSISTEM.AbstractMovement, P<:EcoSISTEM.AbstractParams}","page":"API","title":"EcoSISTEM.SpeciesList","text":"SpeciesList{R <: AbstractRequirement,\n  MO <: AbstractMovement, P <: AbstractParams}(numspecies::Int64,\n  numtraits::Int64, abun_dist::Distribution, req::R,\n  movement::MO, params::P)\n\nFunction to create a SpeciesList given a number of species, the number of traits they possess, their abundances, requirement from the environment and their movement kernel.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.SpeciesList-Union{Tuple{P}, Tuple{T}, Tuple{MO}, Tuple{R}, Tuple{Int64, Int64, Vector{Int64}, R, MO, T, P, Vector{Bool}}} where {R<:EcoSISTEM.AbstractRequirement, MO<:EcoSISTEM.AbstractMovement, T<:Diversity.API.AbstractTypes, P<:EcoSISTEM.AbstractParams}","page":"API","title":"EcoSISTEM.SpeciesList","text":"SpeciesList{R <: AbstractRequirement, MO <: AbstractMovement,\n  T <: AbstractTypes, P <: AbstractParams}(numspecies::Int64,\n  numtraits::Int64, abun_dist::Distribution, req::R,\n  movement::MO, phy::T, params::P)\n\nFunction to create a SpeciesList given a number of species, the number of traits they possess, their abundances, requirement from the environment and their movement kernel and any type of AbstractTypes.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.TempBin","page":"API","title":"EcoSISTEM.TempBin","text":"TempBin{C <: Int} <: ContinuousTrait{C}\n\nTrait type that holds binned temperature preference information created through ClimatePref. Holds an array of counts per temperature band (°C).\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Torus","page":"API","title":"EcoSISTEM.Torus","text":"Torus <: BoundaryCondition\n\nA toroidal boundary where species can cross both boundaries.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.TraitCollection2","page":"API","title":"EcoSISTEM.TraitCollection2","text":"TraitCollection2{T1, T2} <: AbstractTraits{Tuple{T1, T2}}\n\nTrait collection that holds two trait types, TR1 and TR2.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.TraitCollection3","page":"API","title":"EcoSISTEM.TraitCollection3","text":"TraitCollection3{T1, T2, T3} <: AbstractTraits{Tuple{T1, T2, T3}}\n\nTrait collection that holds three trait types, TR1, TR2 and TR3.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Trapeze","page":"API","title":"EcoSISTEM.Trapeze","text":"Trapeze{TR} <: AbstractTraitRelationship{TR}\n\nThe relationship between a continuous trait and its environment, paramaterised on any TR.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Trapezoid","page":"API","title":"EcoSISTEM.Trapezoid","text":"Trapezoid{T<:Real} <: ContinuousUnivariateDistribution\n\nTrapezoidal distribution as described at https://en.wikipedia.org/wiki/Trapezoidal_distribution.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Unif","page":"API","title":"EcoSISTEM.Unif","text":"Trapeze{TR} <: AbstractTraitRelationship{TR}\n\nThe relationship between a continuous trait and its environment, paramaterised on any TR.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.VirusTypes","page":"API","title":"EcoSISTEM.VirusTypes","text":"VirusTypes{TR <: AbstractTraits,\n             T <: AbstractTypes} <: AbstractTypes\n\nVirusTypes holds information on the virus classes, such as the name of each class, their trait match to the environment, initial abundances and types.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.VolWaterBudget","page":"API","title":"EcoSISTEM.VolWaterBudget","text":"VolWaterBudget <: AbstractBudget{typeof(1.0*mm)}\n\nThis budget type has a matrix of water volumes, representing the energy budget of each subcommunity in the abiotic environment at a fixed point in time.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.VolWaterRequirement","page":"API","title":"EcoSISTEM.VolWaterRequirement","text":"VolWaterRequirement <: Abstract1Requirement{typeof(1.0*mm)}\n\nA vector of soil water volume requirements (m^3) for each species.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.VolWaterTimeBudget","page":"API","title":"EcoSISTEM.VolWaterTimeBudget","text":"VolWaterTimeBudget <: AbstractBudget{typeof(1.0*mm)}\n\nThis budget type has a matrix of volumetric soil water units, representing the water budget of each subcommunity in the abiotic environment along with which time dimension we are interested in.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.WaterBudget","page":"API","title":"EcoSISTEM.WaterBudget","text":"WaterBudget <: AbstractBudget{typeof(1.0*mm)}\n\nThis budget type has a matrix of rainfall energy units, representing the energy budget of each subcommunity in the abiotic environment at a fixed point in time.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.WaterRequirement","page":"API","title":"EcoSISTEM.WaterRequirement","text":"WaterRequirement <: Abstract1Requirement{typeof(1.0*mm)}\n\nA vector of water requirements (mm) for each species.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.WaterTimeBudget","page":"API","title":"EcoSISTEM.WaterTimeBudget","text":"WaterTimeBudget <: AbstractBudget{typeof(1.0*mm)}\n\nThis budget type has a matrix of rainfall units, representing the water budget of each subcommunity in the abiotic environment along with which time dimension we are interested in.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.additiveTR2","page":"API","title":"EcoSISTEM.additiveTR2","text":"additiveTR2{TR1, TR2} <: AbstractTraitRelationship{Tuple{TR1, TR2}}\n\nType that houses multiple AbstractTraitRelationships for two trait and habitat levels.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.additiveTR3","page":"API","title":"EcoSISTEM.additiveTR3","text":"multiplicativeTR3{TR1, TR2, TR3} <: AbstractTraitRelationship{Tuple{TR1, TR2, TR3}}\n\nType that houses multiple AbstractTraitRelationships for three trait and habitat levels.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.multiplicativeTR2","page":"API","title":"EcoSISTEM.multiplicativeTR2","text":"multiplicativeTR2{TR1, TR2} <: AbstractTraitRelationship{Tuple{TR1, TR2}}\n\nType that houses multiple AbstractTraitRelationships for two trait and habitat levels.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.multiplicativeTR3","page":"API","title":"EcoSISTEM.multiplicativeTR3","text":"multiplicativeTR3{TR1, TR2, TR3} <: AbstractTraitRelationship{Tuple{TR1, TR2, TR3}}\n\nType that houses multiple AbstractTraitRelationships for three trait and habitat levels.\n\n\n\n\n\n","category":"type"},{"location":"api/#Base.isapprox-Tuple{EcoSISTEM.AbstractEpiSystem, EcoSISTEM.AbstractEpiSystem}","page":"API","title":"Base.isapprox","text":"isapprox(epi_1::AbstractEpiSystem, epi_2::AbstractEpiSystem; kwargs...)\n\nCompare two EpiSystems for approximate equality. Specifically, compares the EpiLandscapes of the two systems.\n\nKeyword arguments\n\nAnything to pass to Base.isapprox.\n\nnote: Note\nYou may want to pass in atol or rtol to loosen the equality tolerance.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.BM","page":"API","title":"EcoSISTEM.BM","text":"BM(T::Real, σ²::Float64, start::Float64, lab::String=\"\")\n\nFunction to evolve a Real value through Brownian motion, with a starting value,  start, and rate, σ².\n\n\n\n\n\n","category":"function"},{"location":"api/#EcoSISTEM.ContinuousEvolve-Tuple{Union{Float64, Unitful.Quantity{Float64, D, U} where {D, U}}, Union{Float64, Unitful.Quantity{Float64, D, U} where {D, U}}, Phylo.BinaryTree}","page":"API","title":"EcoSISTEM.ContinuousEvolve","text":"ContinuousEvolve(val::Union{Float64, Unitful.Quantity{Float64}}, var::Union{Float64, Unitful.Quantity{Float64}}, tree::BinaryTree)\n\nFunction to evolve a continuous trait along a BinaryTree, tree via Brownian motion. Takes in a starting value, val and a variance, var.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.DiscreteEvolve","page":"API","title":"EcoSISTEM.DiscreteEvolve","text":"DiscreteEvolve(numTraits::Int64, tree::BinaryTree)\n\nFunction to evolve a discrete switching trait along a BinaryTree, tree. Takes in a number of traits, numTraits to be switched between and rate to switch between traits, switch_rate with default value of 0.5.\n\n\n\n\n\n","category":"function"},{"location":"api/#EcoSISTEM.HabitatLoss-Tuple{EcoSISTEM.AbstractEcosystem, EcoSISTEM.AbstractHabitat, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.HabitatLoss","text":"HabitatLoss(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to destroy habitat for one timestep of the ecosystem using HabitatUpdate information.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.NoChange-Tuple{EcoSISTEM.AbstractEcosystem, EcoSISTEM.AbstractHabitat, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.NoChange","text":"NoChange(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to keep the habitat the same for one timestep of the model.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.RainfallChange-Tuple{EcoSISTEM.AbstractEcosystem, ContinuousHab, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.RainfallChange","text":"RainfallChange(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to change the rainfall for one timestep of the ecosystem using HabitatUpdate information.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.SEI3HRD_wrapper","page":"API","title":"EcoSISTEM.SEI3HRD_wrapper","text":"SEI3HRD_wrapper(grid_size::Tuple{Int64, Int64}, area::Unitful.Area{Float64}, params::NamedTuple, runtimes::NamedTuple)\n\nFunction to simulate SEI3HRD stochastic realisations, given a grid dimension, grid_size, area size, a set of model parameters, params, and running parameters, runtimes.\n\nOutputs an abundance matrice of compartment by grid cell over time. Compartments for the SEI3HRD model are: Susceptible, Exposed, Asymptomatic Infected, Pre-symptomatic Infected, Symptomatic Infected, Hospitalised, Recovered, Dead.\n\n\n\n\n\n","category":"function"},{"location":"api/#EcoSISTEM.SEI3HRD_wrapper!","page":"API","title":"EcoSISTEM.SEI3HRD_wrapper!","text":"SEI3HRD_wrapper!(grid_size::Tuple{Int64, Int64}, area::Unitful.Area{Float64}, params::NamedTuple, runtimes::NamedTuple, abuns::Array{Int64, 3})\n\nFunction to simulate SEI3HRD stochastic realisations, given a grid dimension, grid_size, area size, a set of model parameters, params, and running parameters, runtimes.\n\nFills an abundance matrice of compartment by grid cell over time. Compartments for the SIR model are: Susceptible, Exposed, Asymptomatic Infected, Pre-symptomatic Infected, Symptomatic Infected, Hospitalised, Recovered, Dead.\n\n\n\n\n\n","category":"function"},{"location":"api/#EcoSISTEM.SIR_wrapper!-Tuple{Tuple{Int64, Int64}, Union{Unitful.Quantity{Float64, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋^2, U}} where {L, S}} where U, NamedTuple, NamedTuple, Array{Int64, 3}}","page":"API","title":"EcoSISTEM.SIR_wrapper!","text":"SIR_wrapper!(grid_size::Tuple{Int64, Int64}, area::Unitful.Area{Float64}, params::NamedTuple, runtimes::NamedTuple, abuns::Array{Int64, 3})\n\nFunction to simulate simple SIR stochastic realisations, given a grid dimension, grid_size, area size, a set of model parameters, params, and running parameters, runtimes.\n\nFills an abundance matrice of compartment by grid cell over time. Compartments for the SIR model are: Susceptible, Infected, Recovered, Dead.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.SIR_wrapper-Tuple{Tuple{Int64, Int64}, Union{Unitful.Quantity{Float64, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋^2, U}} where {L, S}} where U, NamedTuple, NamedTuple}","page":"API","title":"EcoSISTEM.SIR_wrapper","text":"SIR_wrapper(grid_size::Tuple{Int64, Int64}, area::Unitful.Area{Float64}, params::NamedTuple, runtimes::NamedTuple)\n\nFunction to simulate simple SIR stochastic realisations, given a grid dimension, grid_size, area size, a set of model parameters, params, and running parameters, runtimes.\n\nOutputs an abundance matrice of compartment by grid cell over time. Compartments for the SIR model are: Susceptible, Infected, Recovered, Dead.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.TempChange-Tuple{EcoSISTEM.AbstractEcosystem, ContinuousHab, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.TempChange","text":"TempChange(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to increase the temperature for one timestep of the ecosystem using HabitatUpdate information.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.TempChange-Tuple{EcoSISTEM.AbstractEpiSystem, ContinuousHab, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.TempChange","text":"TempChange(epi::EpiSystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to change temperature at a rate set by the habitat hab for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.TempFluct-Tuple{EcoSISTEM.AbstractEcosystem, ContinuousHab, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.TempFluct","text":"TempFluct(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to fluctuate the temperature for one timestep of the ecosystem using HabitatUpdate information.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM._construct_shrunk_matrix-Tuple{Matrix{T} where T, Any, Any}","page":"API","title":"EcoSISTEM._construct_shrunk_matrix","text":"_construct_shrunk_matrix\n\nConstruct a shrunk matrix by selecting certain rows and columns specified by row_idxs and col_idxs from AbstractMatrix M.\n\nReturn an AxisArray{T, 2}. The axes will be the selected subset of the original axes if M is an AxisArray. If M is a normal matrix, the axes of the returned AxisArray are the selected coordinates.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM._convert_population-Tuple{Matrix{var\"#s34\"} where var\"#s34\"<:Real, AbstractMatrix{Bool}}","page":"API","title":"EcoSISTEM._convert_population","text":"_convert_population\n\nConvert populatioin matrix to Int matrix by filling in the inactive area with 0 population and rounding the active area.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.abundances-Tuple{CachedEcosystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.abundances","text":"abundances(cache::CachedEcosystem, tm::Unitful.Time)\n\nFunction to extract abundances for an ecosystem, cache, at a certain point in time, tm. If the abundances for that time are missing from the ecosystem, then the function checks on disk for the last saved version and simulates forward.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.applycontrols!-Tuple{EcoSISTEM.AbstractEpiSystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.applycontrols!","text":"applycontrols!(epi::EpiSystem, timestep::Unitful.Time)\n\nFunction to apply control strategies to an EpiSystem for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.assign_traits!-Tuple{Phylo.AbstractTree, DataFrames.DataFrame}","page":"API","title":"EcoSISTEM.assign_traits!","text":"assign_traits!(tree::AbstractTree, start::Vector{Float64},\n  σ²::Vector{Float64})\n\nFunction to evolve continuous functional traits through a phylogenetic tree through Brownian motion, with a starting value, start, and rate, σ².\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.assign_traits!-Tuple{Phylo.AbstractTree, Vector{Float64}, DataFrames.DataFrame}","page":"API","title":"EcoSISTEM.assign_traits!","text":"assign_traits!(tree::AbstractTree, switch_rate::Vector{Float64},\ntraits::Vector{Vector{String}})\n\nFunction to evolve categorical functional traits through a phylogenetic tree with a specific switching rate.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.budgetupdate!-Tuple{EcoSISTEM.AbstractEcosystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.budgetupdate!","text":"budgetupdate!(eco::AbstractEcosystem, timestep::Unitful.Time)\n\nFunction to update the budget of an ecosystem for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.calc_lookup_moves!-Tuple{NoBoundary, Int64, Int64, Int64, EcoSISTEM.AbstractEcosystem, Int64}","page":"API","title":"EcoSISTEM.calc_lookup_moves!","text":"calc_lookup_moves!(bound, x::Int64, y::Int64, sp::Int64, eco::Ecosystem, abun::Int64)\n\nFunction to calculate the number of moves taken by a species, sp, from a specific grid square location (x, y). There is a boundary condition, bound, which determines how the species can move across space (see AbstractBoundary). The total abundance of individuals is given in abun, which may be the number of births in the timestep, or total indiviuals.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.classupdate!-Tuple{EpiSystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.classupdate!","text":"classupdate!(epi::EpiSystem, timestep::Unitful.Time)\n\nFunction to update disease class abundances for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.combineTR-Tuple{Union{multiplicativeTR2, multiplicativeTR3}}","page":"API","title":"EcoSISTEM.combineTR","text":"combineTR\n\nFunction that combines the output of multiple trait relationships, which varies depending on whether multiplicative, additive etc.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.convert_coords","page":"API","title":"EcoSISTEM.convert_coords","text":"convert_coords(eco, i::Int64, width::Int64)\nconvert_coords(eco, x::Int64, y::Int64, width::Int64)\n\nFunction to convert coordinates from two-dimensional (x,y) format to one dimension (i), or vice versa, using the width of the grid. This function can also be applied to arrays of coordinates.\n\n\n\n\n\n","category":"function"},{"location":"api/#EcoSISTEM.convert_population-Union{Tuple{Matrix{T} where T}, Tuple{U}, Tuple{Matrix{T} where T, U}} where U<:Integer","page":"API","title":"EcoSISTEM.convert_population","text":"function convert_population(\n    initial_population,\n    intnum::U = Int64(1)\n)\n\nConvert population matrix to Int matrix by filling in the inactive area with 0 population and rounding the active area.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.emptyepilandscape-Union{Tuple{R}, Tuple{U}, Tuple{GridEpiEnv, EpiList, U}, Tuple{GridEpiEnv, EpiList, U, Type{R}}} where {U<:Integer, R<:Random.AbstractRNG}","page":"API","title":"EcoSISTEM.emptyepilandscape","text":"emptyepilandscape(epienv::GridEpiEnv, epilist::EpiList)\n\nFunction to create an empty EpiLandscape given a GridEpiEnv and a EpiList.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.emptygridlandscape-Tuple{GridAbioticEnv, SpeciesList}","page":"API","title":"EcoSISTEM.emptygridlandscape","text":"emptygridlandscape(gae::GridAbioticEnv, spplist::SpeciesList)\n\nFunction to create an empty GridLandscape given a GridAbioticEnv and a SpeciesList.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.emptypopulate!-Union{Tuple{R}, Tuple{AB}, Tuple{GridLandscape, SpeciesList, AB, R}} where {AB<:EcoSISTEM.AbstractAbiotic, R<:EcoSISTEM.AbstractTraitRelationship}","page":"API","title":"EcoSISTEM.emptypopulate!","text":"emptypopulate!(ml::GridLandscape, spplist::SpeciesList,\n               abenv::AB, rel::R) where {AB <: EcoSISTEM.AbstractAbiotic, R <: EcoSISTEM.AbstractTraitRelationship}\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.energy_adjustment-Tuple{EcoSISTEM.AbstractEcosystem, EcoSISTEM.AbstractBudget, Int64, Int64}","page":"API","title":"EcoSISTEM.energy_adjustment","text":"energy_adjustment(eco::Ecosystem, bud::AbstractBudget, i::Int64, sp::Int64)\n\nFunction to calculate how much birth and death rates should be adjusted by, according to how much energy is available, bud, in the grid square, i, and how much energy the species, sp, requires.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.equalpop-Tuple{EqualPop, Any}","page":"API","title":"EcoSISTEM.equalpop","text":"equalpop(params::EqualPop, numspp)\n\nFunction that takes demographic parameters from type EqualPop and converts them into type PopGrowth based on the number of species (numspp).\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.eraAE-Tuple{EcoSISTEM.ClimatePref.ERA, Unitful.Quantity{Float64, D, U} where {D, U}, Union{Unitful.Quantity{Float64, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋^2, U}} where {L, S}} where U}","page":"API","title":"EcoSISTEM.eraAE","text":"eraAE(era::ERA, maxbud::Unitful.Quantity{Float64})\n\nFunction to create a ContinuousHab, SimpleBudget type abiotic environment from an ERA type climate. It either creates a SimpleBudget type filled with the maximum budget value maxbud or uses a provided budget of type SolarTimeBudget. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.eraChange-Tuple{EcoSISTEM.AbstractEcosystem, ContinuousTimeHab, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.eraChange","text":"eraChange(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to step the ERA climate forward by one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.genlookups-Tuple{EcoSISTEM.AbstractHabitat, GaussianKernel}","page":"API","title":"EcoSISTEM.genlookups","text":"genlookups(hab::AbstractHabitat, mov::GaussianMovement)\n\nFunction to generate lookup tables, which hold information on the probability of moving to neighbouring squares.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.geom_mean_abun-Tuple{Ecosystem, Vector{Float64}}","page":"API","title":"EcoSISTEM.geom_mean_abun","text":"geom_mean_abun(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate the geometric mean abundance for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.get_3d_km_grid_axis_array-Tuple{SQLite.DB, Vector{String}, String, String}","page":"API","title":"EcoSISTEM.get_3d_km_grid_axis_array","text":"get_3d_km_grid_axis_array(cn::SQLite.DB, dims::Array{String,1}, msr::String, tbl::String)\n\nFunction to take Scottish Population data from an SQLite database and convert to an axis array.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.get_neighbours","page":"API","title":"EcoSISTEM.get_neighbours","text":"get_neighbours(mat::Matrix, x_coord::Int64, y_coord::Int64, chess::Int64=4)\n\nFunction to get the neighbours of a grid square in a matrix in 4 or 8 directions\n\n\n\n\n\n","category":"function"},{"location":"api/#EcoSISTEM.get_traits","page":"API","title":"EcoSISTEM.get_traits","text":"get_traits(tree::AbstractTree, tips::Bool=true)\n\nFunction to retrieve functional traits assigned to a phylogenetic tree, either just tips or all nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/#EcoSISTEM.getbudget-Tuple{EcoSISTEM.AbstractEcosystem}","page":"API","title":"EcoSISTEM.getbudget","text":"getbudget(eco::Ecosystem)\n\nFunction to extract budget from Ecosystem object.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.getdimension-Tuple{EcoSISTEM.AbstractEcosystem}","page":"API","title":"EcoSISTEM.getdimension","text":"getdimension(eco::Ecosystem)\n\nFunction to extract dimension of habitat from Ecosystem object.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.getdispersaldist-Tuple{EcoSISTEM.AbstractEcosystem, Int64}","page":"API","title":"EcoSISTEM.getdispersaldist","text":"getdispersaldist(eco::Ecosystem)\n\nFunction to extract average dispersal distance of species from Ecosystem object. Returns a vector of distances, unless a specific species is provided as a String or Integer.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.getdispersalvar-Tuple{EcoSISTEM.AbstractEcosystem, Int64}","page":"API","title":"EcoSISTEM.getdispersalvar","text":"getdispersalvar(eco::Ecosystem)\n\nFunction to extract dispersal varaince of species from Ecosystem object. Returns a vector of distances, unless a specific species is provided as a String or Integer.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.getgridsize-Tuple{EcoSISTEM.AbstractEcosystem}","page":"API","title":"EcoSISTEM.getgridsize","text":"getgridsize(eco::Ecosystem)\n\nFunction to extract grid cell size of habitat from Ecosystem object.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.gethabitat-Tuple{EcoSISTEM.AbstractEcosystem}","page":"API","title":"EcoSISTEM.gethabitat","text":"gethabitat(eco::Ecosystem)\n\nFunction to extract habitat from Ecosystem object.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.getlookup-Tuple{EcoSISTEM.AbstractEcosystem, Int64}","page":"API","title":"EcoSISTEM.getlookup","text":"getlookup(eco::Ecosystem)\n\nFunction to extract movement lookup table of species from Ecosystem object.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.getpref-Union{Tuple{T}, Tuple{T, Symbol}} where T<:EcoSISTEM.AbstractTraits","page":"API","title":"EcoSISTEM.getpref","text":"getpref(traits::T, field::Symbol) where T <: AbstractTraits\n\nFunction to extract trait preferences for all species in the ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.getrelationship-Union{Tuple{R}, Tuple{R, Symbol}} where R<:EcoSISTEM.AbstractTraitRelationship","page":"API","title":"EcoSISTEM.getrelationship","text":"getpref(traits::T, field::Symbol) where T <: AbstractTraits\n\nFunction to extract the trait relationship of all species in the ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.getsize-Tuple{EcoSISTEM.AbstractEcosystem}","page":"API","title":"EcoSISTEM.getsize","text":"getsize(eco::Ecosystem)\n\nFunction to extract size of habitat from Ecosystem object.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.gettraitrel-Tuple{EcoSISTEM.AbstractEcosystem}","page":"API","title":"EcoSISTEM.gettraitrel","text":"gettraitrel(eco::Ecosystem)\n\nFunction to extract trait relationships.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.habitatupdate!-Tuple{EcoSISTEM.AbstractEcosystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.habitatupdate!","text":"habitatupdate!(eco::AbstractEcosystem, timestep::Unitful.Time)\n\nFunction to update the habitat of an ecosystem for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.initialise_output_abuns-Tuple{Array, NamedTuple}","page":"API","title":"EcoSISTEM.initialise_output_abuns","text":"initialise_output_abuns(\n    abuns::Array,\n    axes::NamedTuple;\n    h5fn=joinpath(pwd(),\"abundances.h5\")\n)\n\nCreate an HDF5 file h5fn to store abundance. Preallocate a fix-sized array to store abundance for each compartment, grid location and timestep. Fill in values for compartments, grid locations and timesteps.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.makeunique-Tuple{Ecosystem}","page":"API","title":"EcoSISTEM.makeunique","text":"makeunique(eco::Ecosystem)\n\nFunction to convert type of similarity in SpeciesList to UniqueTypes, i.e. an identity matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.mean_abun-Tuple{Ecosystem, Vector{Float64}}","page":"API","title":"EcoSISTEM.mean_abun","text":"mean_abun(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate the mean arithmetic abundance for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.meta_shannon-Tuple{Ecosystem, Vector{Float64}}","page":"API","title":"EcoSISTEM.meta_shannon","text":"meta_shannon(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate the Shannon entropy for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.meta_simpson-Tuple{Ecosystem, Vector{Float64}}","page":"API","title":"EcoSISTEM.meta_simpson","text":"meta_simpson(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate the Simpson diversity for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.meta_speciesrichness-Tuple{Ecosystem, Vector{Float64}}","page":"API","title":"EcoSISTEM.meta_speciesrichness","text":"meta_speciesrichness(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate the species richness for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.move!-Tuple{EcoSISTEM.AbstractEcosystem, AlwaysMovement, Int64, Int64, Matrix{Int64}, Int64}","page":"API","title":"EcoSISTEM.move!","text":"move!(eco::Ecosystem, ::AbstractMovement, i::Int64, sp::Int64, grd::Array{Int64, 2}, abun::Int64)\n\nFunction to calculate the movement of species sp from a given position in the landscape i, using the lookup table found in the Ecosystem and updating the movement patterns on a cached grid, grd. Optionally, a number of births can be provided, so that movement only takes place as part of the birth process, instead of the entire population\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.parse_hdf5-Tuple{Any}","page":"API","title":"EcoSISTEM.parse_hdf5","text":"parse_hdf5(path; grid=\"10k\", component=\"scotland_2018\")\n\nParse HDF5-format file at path, containing component. The data is read on a grid with cells of size grid meters x grid meters and ages are assumed to be binned into 5 years intervals, starting at zero and going up to 90+.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.pd-Tuple{Ecosystem, Vector{Float64}}","page":"API","title":"EcoSISTEM.pd","text":"pd(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate Faith's phylogenetic diversity (PD) for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.peakedgradAE-Tuple{Union{Unitful.Quantity{Float64, 𝚯, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝚯, U}} where {L, S}} where U, Union{Unitful.Quantity{Float64, 𝚯, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝚯, U}} where {L, S}} where U, Tuple{Int64, Int64}, Unitful.Quantity{Float64, D, U} where {D, U}, Union{Unitful.Quantity{Float64, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋^2, U}} where {L, S}} where U, Unitful.Quantity{Float64, 𝚯 𝐓^-1, U} where U, Matrix{Bool}}","page":"API","title":"EcoSISTEM.peakedgradAE","text":"peakedgradAE(minT::Unitful.Temperature{Float64},\n   maxT::Unitful.Temperature{Float64},\n   dimension::Tuple{Int64, Int64}, maxbud::Unitful.Quantity{Float64},\n   area::Unitful.Area{Float64}, rate::Quantity{Float64, 𝚯*𝐓^-1},\n   active::Array{Bool, 2})\n\nFunction to create a temperature gradient ContinuousHab, SimpleBudget type abiotic environment. Given a min and max temperature, it generates a gradient from minima at the top and bottom peaking to maximum in the middle. It creates a ContinuousHab environment with dimensions dimension and a specified area area. It also creates a SimpleBudget type filled with the maximum budget value maxbud. The rate of temperature change is specified using the parameter rate. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.plot_epidynamics","page":"API","title":"EcoSISTEM.plot_epidynamics","text":"plot_epidynamics(\n    epi::AbstractEpiSystem,\n    abuns::AbstractArray{<:Integer, 3};\n    category_map=nothing,\n)\n\nPlot the dynamics of abuns summed over space, as a function of time.\n\nArguments\n\nepi: The AbstractEpiSystem to plot.\nabuns: The array of abundances to plot, of size Ncompartments x Ncells x Nsteps\n\nKeyword arguments\n\ncategory_map: An iterable of key-value pairs where the keys are category names, and the   values are a list of compartment indices associated with that category. These   compartments will be summed in the plot. For example, the following will plot the sum of   compartments 1 and 2 as the Susceptible category, and the sum of compartments 3 and 4   as the Infected category.\n  category_map = (\"Susceptible\" => [1, 2], \"Infected\" => [3, 4])\nIf category_map is nothing, all compartments in epi will be plotted separately   with their corresponding names.\n\n\n\n\n\n","category":"function"},{"location":"api/#EcoSISTEM.plot_epiheatmaps","page":"API","title":"EcoSISTEM.plot_epiheatmaps","text":"plot_epiheatmaps(\n    epi::AbstractEpiSystem,\n    abuns::AbstractArray{<:Integer, 3};\n    compartment=\"Exposed\",\n    steps=[],\n)\n\nPlot heatmaps of abuns for compartment at steps.\n\nArguments\n\nepi: The AbstractEpiSystem to plot.\nabuns: The array of abundances to plot, of size Ncompartments x Ncells x Nsteps\n\nKeyword arguments\n\ncompartment: The compartment to plot\nsteps: A list of steps to plot (one heatmap for each step). If empty, plots 4   equally-spaced steps.\n\nnote: Note\nHeatmaps are transposed by default. Pass in transpose=false to turn this off.\n\n\n\n\n\n","category":"function"},{"location":"api/#EcoSISTEM.populate!-Union{Tuple{R}, Tuple{EE}, Tuple{EpiLandscape, EpiList, EE, R}} where {EE<:EcoSISTEM.AbstractEpiEnv, R<:EcoSISTEM.AbstractTraitRelationship}","page":"API","title":"EcoSISTEM.populate!","text":"populate!(ml::EpiLandscape, epilist::EpiList, epienv::EE, rel::R)\n\nFunction to populate an EpiLandscape with information on each disease class in the EpiList.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.raingrad-Tuple{Union{Unitful.Quantity{Float64, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋, U}} where {L, S}} where U, Union{Unitful.Quantity{Float64, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋, U}} where {L, S}} where U, Union{Unitful.Quantity{Float64, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋, U}} where {L, S}} where U, Tuple{Int64, Int64}, Unitful.Quantity{Float64, 𝐋 𝐓^-1, U} where U}","page":"API","title":"EcoSISTEM.raingrad","text":"raingrad(minT::Unitful.Temperature{Float64}, maxT::Unitful.Temperature{Float64},\n  size::Unitful.Length{Float64},\n  dim::Tuple{Int64, Int64}, rate::Quantity{Float64, 𝚯*𝐓^-1})\n\nFunction to create a ContinuousHab habitat with a rainfall gradient.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.raingradAE-Tuple{Union{Unitful.Quantity{Float64, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋, U}} where {L, S}} where U, Union{Unitful.Quantity{Float64, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋, U}} where {L, S}} where U, Tuple{Int64, Int64}, Unitful.Quantity{Float64, D, U} where {D, U}, Union{Unitful.Quantity{Float64, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋^2, U}} where {L, S}} where U, Unitful.Quantity{Float64, 𝐋 𝐓^-1, U} where U, Matrix{Bool}}","page":"API","title":"EcoSISTEM.raingradAE","text":"raingradAE(min::Unitful.Temperature{Float64},\n  max::Unitful.Temperature{Float64},\n  dimension::Tuple{Int64, Int64}, maxbud::Float64,\n  area::Unitful.Area{Float64}, rate::Quantity{Float64, typeof(𝚯*𝐓^-1)},\n  active::Array{Bool, 2})\n\nFunction to create a rain gradient ContinuousHab, SimpleBudget type abiotic environment. Given a min and max rainfall, it generates a gradient from minimum at the bottom to maximum at the top. It creates a ContinuousHab environment with dimensions dimension and a specified area area. It also creates a SimpleBudget type filled with the maximum budget value maxbud. The rate of rainfall change is specified using the parameter rate. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.randomniches-Tuple{Tuple, Vector{Int64}, Float64, Vector{T} where T, Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.randomniches","text":"randomniches(dimension::Tuple, types::Vector{String}, clumpiness::Float64, weights::Vector)\n\nFunction to create a DiscreteHab habitat of dimension dimension, made up of sampled string types, types, that have a weighting, weights and clumpiness parameter, clumpiness.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.reenergise!-Tuple{Ecosystem, Union{Float64, Unitful.Quantity{Float64, D, U} where {D, U}}, Tuple{Int64, Int64}}","page":"API","title":"EcoSISTEM.reenergise!","text":"reenergise!(eco::Ecosystem, budget::Union{Float64, Unitful.Quantity{Float64}}, grid::Tuple{Int64, Int64})\n\nFunction to refill an ecosystem eco, with energy from a budget value, budget and a grid size.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.repopulate!-Tuple{Ecosystem}","page":"API","title":"EcoSISTEM.repopulate!","text":"repopulate!(eco::Ecosystem, abun::Int64)\n\nFunction to repopulate an ecosystem eco, with option for including trait preferences. An additional abun parameter can be included, in order to repopulate the ecosystem with a specified number of individuals.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.resetrate!-Tuple{EcoSISTEM.AbstractEcosystem, Unitful.Quantity{Float64, Unitful.Dimensions{(Unitful.Dimension{:Time}(-1//1),)}, U} where U}","page":"API","title":"EcoSISTEM.resetrate!","text":"resetrate!(eco::Ecosystem, rate::Quantity{Float64, typeof(𝐓^-1)})\n\nFunction to reset the rate of habitat change for a species.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.runscenario!-Tuple{Ecosystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, SimpleScenario, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.runscenario!","text":"runscenario!(eco::Ecosystem, timestep::Unitful.Time, scenario::S, currentstep::Unitful.Time) where S <: AbstractScenario\n\nThis function runs any scenario type for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.shrink_to_active-Union{Tuple{A}, Tuple{AM}, Tuple{AM, A}} where {AM<:(AbstractMatrix{T} where T), A<:(AbstractMatrix{var\"#s233\"} where var\"#s233\"<:Bool)}","page":"API","title":"EcoSISTEM.shrink_to_active","text":"_shrink_to_active(M::AbstractMatrix, active::AbstractMatrix{<:Bool})\n\nShrink the matrix M to the minimum rectangular region which contains all active cells, as defined by active. Returns the shrunk matrix.\n\nIf active is not provided, automatically determines the active region by masking out entries which areNaNormissing`.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.simplehabitat-Tuple{Unitful.Quantity, Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}, Tuple{Int64, Int64}}","page":"API","title":"EcoSISTEM.simplehabitat","text":"simplehabitat(val::Unitful.Quantity, size::Unitful.Length,\ndim::Tuple{Int64, Int64})\n\nFunction to create a ContinuousHab habitat of dimension dim, with cell size and filled value, val.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.simplehabitatAE-Tuple{Union{Float64, Unitful.Quantity{Float64, D, U} where {D, U}}, Tuple{Int64, Int64}, Unitful.Quantity{Float64, D, U} where {D, U}, Union{Unitful.Quantity{Float64, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋^2, U}} where {L, S}} where U, Matrix{Bool}}","page":"API","title":"EcoSISTEM.simplehabitatAE","text":"simplehabitatAE(val::Union{Float64, Unitful.Quantity{Float64}},\n    dimension::Tuple{Int64, Int64}, maxbud::Float64, area::Unitful.Area{Float64},\n    active::Array{Bool, 2})\n\nFunction to create a simple ContinuousHab, SimpleBudget type abiotic environment. It creates a ContinuousHab filled with a given value, val, dimensions (dimension) and a specified area (area). It also creates a SimpleBudget type filled with the maximum budget value (maxbud). The rate of temperature change is specified using the parameter rate. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.simplehabitatAE-Union{Tuple{M}, Tuple{C}, Tuple{Union{Float64, Unitful.Quantity{Float64, D, U} where {D, U}}, Tuple{Int64, Int64}, Union{Unitful.Quantity{Float64, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋^2, U}} where {L, S}} where U, M, C}} where {C<:EcoSISTEM.AbstractControl, M<:AbstractMatrix{Bool}}","page":"API","title":"EcoSISTEM.simplehabitatAE","text":"function simplehabitatAE(\n    val::Union{Float64, Unitful.Quantity{Float64}},\n    dimension::Tuple{Int64, Int64},\n    area::Unitful.Area{Float64},\n    active::AbstractMatrix{Bool},\n    control::C,\n)\n\nFunction to create a simple ContinuousHab type epi environment. It creates a ContinuousHab filled with a given value val, of dimensions dimension and specified area area. If a Bool matrix active of active grid squares is included, this is used, else one is created with all grid cells active.\n\nnote: Note\nThe simulation grid will be shrunk so that it tightly wraps the active values\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.simplenicheAE-Tuple{Int64, Tuple, Unitful.Quantity{Float64, D, U} where {D, U}, Union{Unitful.Quantity{Float64, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋^2, U}} where {L, S}} where U, Matrix{Bool}}","page":"API","title":"EcoSISTEM.simplenicheAE","text":"simplenicheAE(numniches::Int64, dimension::Tuple,\n                    maxBud::Float64, area::Unitful.Area{Float64},\n                    active::Array{Bool, 2})\n\nFunction to create a simple DiscreteHab, SimpleBudget type abiotic environment. Given a number of niche types numniches, it creates a DiscreteHab environment with dimensions dimension and a specified area area. It also creates a SimpleBudget type filled with the maximum budget value maxbud. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.simulate!-Tuple{EcoSISTEM.AbstractEcosystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.simulate!","text":"simulate!(eco::Ecosystem, duration::Unitful.Time, interval::Unitful.Time,\n     timestep::Unitful.Time)\n\nFunction to run an ecosystem, eco for specified length of times, duration, for a particular timestep, 'timestep'.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.simulate!-Tuple{EcoSISTEM.AbstractEpiSystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.simulate!","text":"simulate!(\n    epi::AbstractEpiSystem,\n    duration::Unitful.Time,\n    timestep::Unitful.Time;\n    save=false,\n    save_path=pwd(),\n)\n\nRun an epidemiological system, epi, for specified length of times, duration, for a particular timestep, timestep. If save=true, inputs and outputs are saved as JLSO files at save_path.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.simulate_record!-Tuple{AbstractArray, Ecosystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.simulate_record!","text":"simulate_record!(eco::Ecosystem, duration::Unitful.Time, interval::Unitful.Time,\n     timestep::Unitful.Time)\n\nFunction to run an ecosystem, eco for specified length of times, duration, for a particular timestep, 'timestep', and time interval for abundances to be recorded, interval. Optionally, there may also be a scenario by which the whole ecosystem is updated, such as removal of habitat patches.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.simulate_record!-Tuple{AbstractArray, EpiSystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.simulate_record!","text":"simulate_record!(\n    storage::AbstractArray,\n    epi::EpiSystem,\n    times::Unitful.Time,\n    interval::Unitful.Time,\n    timestep::Unitful.Time;\n    save=false,\n    save_path=pwd(),\n)\n\nRun an epidemiological system, epi, for specified length of times, times, for a particular timestep, timestep, and time interval for abundances to be recorded, interval. Optionally, there may also be a scenario by which the whole ecosystem is updated, such as removal of habitat patches.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.simulate_record_diversity!-Union{Tuple{F}, Tuple{AbstractArray, Ecosystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, SimpleScenario, F, Vector{Float64}}} where F<:Function","page":"API","title":"EcoSISTEM.simulate_record_diversity!","text":"simulate_record_diversity!(storage::AbstractArray, eco::Ecosystem,\n  times::Unitful.Time, interval::Unitful.Time,timestep::Unitful.Time,\n  scenario::SimpleScenario, divfun::Function, qs::Float64)\n\nFunction to run an ecosystem, eco for specified length of times, duration, for a particular timestep, 'timestep', and time interval for a diversity to be calculated and recorded, interval. Optionally, there may also be a scenario by which the whole ecosystem is updated, such as removal of habitat patches.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.sorenson-Tuple{Ecosystem, Vector{Float64}}","page":"API","title":"EcoSISTEM.sorenson","text":"sorenson(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate the Sorenson similarity for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.sum_pop-Union{Tuple{R}, Tuple{Matrix{R}, Int64}} where R<:Real","page":"API","title":"EcoSISTEM.sum_pop","text":"sum_pop(m::Matrix{Int64}, i::Int64)\n\nFunction to sum a population matrix, m, without memory allocation, at a grid location i.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.tematch-Tuple{SpeciesList, EcoSISTEM.AbstractAbiotic}","page":"API","title":"EcoSISTEM.tematch","text":"tematch(sppl::SpeciesList, abenv::AbstractAbiotic)\n\nFunction to check that the types of a trait list and habitat list are the same for a species list (sppl) and abiotic environment (abenv).\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.tempgrad-Tuple{Union{Unitful.Quantity{Float64, 𝚯, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝚯, U}} where {L, S}} where U, Union{Unitful.Quantity{Float64, 𝚯, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝚯, U}} where {L, S}} where U, Union{Unitful.Quantity{Float64, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋, U}} where {L, S}} where U, Tuple{Int64, Int64}, Unitful.Quantity{Float64, 𝚯 𝐓^-1, U} where U}","page":"API","title":"EcoSISTEM.tempgrad","text":"tempgrad(minT::Unitful.Temperature{Float64}, maxT::Unitful.Temperature{Float64},\n  size::Unitful.Length{Float64},\n  dim::Tuple{Int64, Int64}, rate::Quantity{Float64, 𝚯*𝐓^-1})\n\nFunction to create a ContinuousHab habitat with a temperature gradient.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.tempgradAE-Tuple{Union{Unitful.Quantity{Float64, 𝚯, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝚯, U}} where {L, S}} where U, Union{Unitful.Quantity{Float64, 𝚯, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝚯, U}} where {L, S}} where U, Tuple{Int64, Int64}, Unitful.Quantity{Float64, D, U} where {D, U}, Union{Unitful.Quantity{Float64, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋^2, U}} where {L, S}} where U, Unitful.Quantity{Float64, 𝚯 𝐓^-1, U} where U, Matrix{Bool}}","page":"API","title":"EcoSISTEM.tempgradAE","text":"tempgradAE(min::Unitful.Temperature{Float64},\n  max::Unitful.Temperature{Float64},\n  dimension::Tuple{Int64, Int64}, maxbud::Float64,\n  area::Unitful.Area{Float64}, rate::Quantity{Float64, typeof(𝚯*𝐓^-1)},\n  active::Array{Bool, 2})\n\nFunction to create a temperature gradient ContinuousHab, SimpleBudget type abiotic environment. Given a min and max temperature, it generates a gradient from minimum at the bottom to maximum at the top. It creates a ContinuousHab environment with dimensions dimension and a specified area area. It also creates a SimpleBudget type filled with the maximum budget value maxbud. The rate of temperature change is specified using the parameter rate. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.traitfun-Tuple{EcoSISTEM.AbstractEcosystem, Int64, Int64}","page":"API","title":"EcoSISTEM.traitfun","text":"traitfun(eco::AbstractEcosystem, pos::Int64, sp::Int64)\n\nFunction to calculate relationship between the current environment and a species' particular trait.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.traitfun-Tuple{EcoSISTEM.AbstractEpiSystem, Int64, Int64}","page":"API","title":"EcoSISTEM.traitfun","text":"traitfun(epi::AbstractEpiSystem, pos::Int64, sp::Int64)\n\nFunction to calculate relationship between the current environment and a particular trait of a disease class.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.traitpopulate!-Union{Tuple{R}, Tuple{AB}, Tuple{GridLandscape, SpeciesList, AB, R}} where {AB<:EcoSISTEM.AbstractAbiotic, R<:EcoSISTEM.AbstractTraitRelationship}","page":"API","title":"EcoSISTEM.traitpopulate!","text":"traitpopulate!(ml::GridLandscape, spplist::SpeciesList,\n               abenv::AbstractAbiotic)\n\nFunction to populate a grid landscape given the abundances found in species list based upon how well the species traits match their environment.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.traitrepopulate!-Tuple{Ecosystem}","page":"API","title":"EcoSISTEM.traitrepopulate!","text":"repopulate!(eco::Ecosystem, abun::Int64)\n\nFunction to repopulate an ecosystem eco, with option for including trait preferences. An additional abun parameter can be included, in order to repopulate the ecosystem with a specified number of individuals.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.transition","page":"API","title":"EcoSISTEM.transition","text":"transition(params::NamedTuple, paramDat::DataFrame, nclasses::Int64, inf_cat = [2], age_categories = 1)\n\nFunction to create transition matrix from SIS parameters and return an EpiParams type that can be used by the model update.\n\n\n\n\n\n","category":"function"},{"location":"api/#EcoSISTEM.trmatch-Tuple{SpeciesList, EcoSISTEM.AbstractTraitRelationship}","page":"API","title":"EcoSISTEM.trmatch","text":"trmatch(sppl::SpeciesList, traitrel::AbstractTraitRelationship)\n\nFunction to check that the types of a trait list and trait relationship list are the same for a species list (sppl) and trait relationship (traitrel).\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.ukChange-Tuple{EpiSystem, ContinuousTimeHab, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.ukChange","text":"ukChange(epi::EpiSystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to step the uk climate forward by one timestep. Will repeat if time counter becomes greater than the number of dimensions in the habitat.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.ukclimateAE-Union{Tuple{C}, Tuple{AxisArrays.AxisArray, Tuple{Int64, Int64}, Union{Unitful.Quantity{Float64, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋^2, U}} where {L, S}} where U, AbstractMatrix{Bool}, C}} where C<:EcoSISTEM.AbstractControl","page":"API","title":"EcoSISTEM.ukclimateAE","text":"function ukclimateAE(\n    climatearray::AxisArray,\n    dimension::Tuple{Int64, Int64},\n    area::Unitful.Area{Float64},\n    active::AbstractMatrix{Bool},\n    control::C,\n    initial_population::AbstractMatrix{<:Integer}=zeros(Int, dimension),\n)\n\nFunction to create a ContinuousTimeHab type epi environment from UK level climate data. It creates a ContinuousTimeHab filled with a given AxisArray climatearray, of dimensions dimension and specified area area. If a Bool matrix active of active grid squares is included, this is used, else one is created with all grid cells active.\n\nnote: Note\nThe simulation grid will be shrunk so that it tightly wraps the active values\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.update!-Tuple{Ecosystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.update!","text":"update!(eco::Ecosystem, time::Unitful.Time)\n\nFunction to update a ecosystem abundances and environment for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.update!-Tuple{EpiSystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.update!","text":"update!(epi::EpiSystem, time::Unitful.Time)\n\nFunction to update disease and virus class abundances and environment for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.update_energy_usage!-Union{Tuple{EcoSISTEM.AbstractEcosystem{A, SpeciesList{Tr, Req, B, C, D}, E}}, Tuple{Req}, Tuple{Tr}, Tuple{E}, Tuple{D}, Tuple{C}, Tuple{B}, Tuple{A}} where {A, B, C, D, E, Tr, Req<:EcoSISTEM.Abstract1Requirement}","page":"API","title":"EcoSISTEM.update_energy_usage!","text":"update_energy_usage!(eco::Ecosystem)\n\nFunction to calculate how much energy has been used up by the current species in each grid square in the ecosystem, eco. This function is parameterised on whether the species have one type of energy requirement or two.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.update_output_abuns-Union{Tuple{U}, Tuple{Matrix{U}, Int64}} where U<:Integer","page":"API","title":"EcoSISTEM.update_output_abuns","text":"update_output_abuns(\n    abuns_t::Matrix,\n    timestep::Int;\n    h5fn=joinpath(pwd(),\"abundances.h5\")\n)\n\nUpdate the existing HDF5 file h5fn with the abundance matrix at a certain timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.virusmove!-Tuple{EcoSISTEM.AbstractEpiSystem, Int64, Int64, Matrix{Float64}, Int64}","page":"API","title":"EcoSISTEM.virusmove!","text":"virusmove!(epi::AbstractEpiSystem, id::Int64, pos::Int64, grd::Array{Int64, 2}, newvirus::Int64)\n\nFunction to calculate the movement of force of infection id from a given position in the landscape pos, using the lookup table found in the EpiSystem and updating the movement patterns on a cached grid, grd. The number of new virus is provided, so that movement only takes place as part of the generation process.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.virusupdate!-Tuple{EpiSystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.virusupdate!","text":"virusupdate!(epi::EpiSystem, time::Unitful.Time)\n\nFunction to update virus abundances and disperse for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.worldclimAE-Tuple{EcoSISTEM.ClimatePref.Worldclim, Unitful.Quantity{Float64, D, U} where {D, U}, Union{Unitful.Quantity{Float64, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋^2, U}} where {L, S}} where U}","page":"API","title":"EcoSISTEM.worldclimAE","text":"worldclimAE(wc::Worldclim, maxbud::Unitful.Quantity{Float64})\n\nFunction to create a ContinuousHab, SimpleBudget type abiotic environment from an Wordclim type climate. It either creates a SimpleBudget type filled with the maximum budget value maxbud or uses a provided budget of type SolarTimeBudget. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.worldclimChange-Tuple{EcoSISTEM.AbstractEcosystem, ContinuousTimeHab, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.worldclimChange","text":"worldclimChange(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to step the Worldclim climate forward by one timestep.\n\n\n\n\n\n","category":"method"},{"location":"model_development/#Model-development","page":"Model Development","title":"Model development","text":"","category":"section"},{"location":"model_development/#Top-priorities","page":"Model Development","title":"Top priorities","text":"","category":"section"},{"location":"model_development/","page":"Model Development","title":"Model Development","text":"Virus seasonality. There will be at least some seasonality with climate and other environmental information could also be considered, such as pollution levels. Work underway to incorporate these types of data into the model.\nClearer designation of the different compartment types. E.g. Disease state, age, gender etc. Work has begun on this, creating a higher dimensional storage array with labelled axes (through AxisArrays).\nMPI. In order to make best use of HPC resources, we should re-implement MPI in this section of the code, based upon the original in the biodiversity code.","category":"page"},{"location":"model_development/#Further-developments","page":"Model Development","title":"Further developments","text":"","category":"section"},{"location":"model_development/","page":"Model Development","title":"Model Development","text":"Add in household structure. This will include a more \"individual based\" model in which different ages and genders are tracked within a cell. However, timing of events is unlikely to be tracked as this is difficult to parallelise. This work was underway, but has been shelved in favour of other priorities.\nAdd in different location types. E.g. schools, work, care homes, general social situations (proxy for pubs, restaurants etc).\nRegionalisation. Working towards an 'irregular' grid structure. However, in the first instance, we could track information like health board or local authorities for each grid cell, and explore lockdown strategies among these different areas on a regular grid.","category":"page"},{"location":"simulation-jl/","page":"-","title":"-","text":"Table of datasets currently in use by EcoSISTEM.jl","category":"page"},{"location":"simulation-jl/","page":"-","title":"-","text":"Preliminary list of parameters/datasets.","category":"page"},{"location":"simulation-jl/","page":"-","title":"-","text":"Name of parameter/ dataset Description Value Source Other info (e.g. stability)\np_s Probability of developing symptoms 0.96 http://gabgoh.github.io/COVID/index.html (From Thibaud's original model) \np_h Probability of hospitalisation 0.2 Guess \ncfr_home Case fatality ratio (at home) 0.1 Guess \ncfr_hospital Case fatality ratio (at hospital) 0.1 Guess \nT_lat Latent period 5 days http://gabgoh.github.io/COVID/index.html (From Thibaud's original model) \nT_asym Asymptomatic period 3 days http://gabgoh.github.io/COVID/index.html (From Thibaud's original model) \nT_sym Symptomatic period 5 days http://gabgoh.github.io/COVID/index.html (From Thibaud's original model) \nT_hosp Hospitalisation period 5 days https://www.icnarc.org/Our-Audit/Audits/Cmp/Reports (From Thibaud's original model) \nT_rec Recovery period 11 days http://gabgoh.github.io/COVID/index.html (From Thibaud's original model) \nmu_1 Probability of becoming Asymptomatic 1/T_lat  \nmu_2 Probability of becoming Symptomatic ps * 1/Tasym  \nhospitalisation Probability of becoming Hospitalised ph * 1/Tsym  \nsigma_1 Probability of Recovery from Asymptomatic (1 - ps) * 1/Tasym  \nsigma_2 Probability of Recovery from Symptomatic (1 - ph) * (1 - cfrhome) * 1/T_rec  \nsigma_hospital Probability of Recovery from Hospital (1 - cfrhosp) * 1/Thosp  \ndeath_home Probability of Death at home cfrhome * 2/Thosp  \ndeath_hospital Probability of Death at hospital cfrhosp * 1/Thosp  \nScotlandDensity2011 Scottish population density at 1km grid  UK census 2011 - A Reeves 'Covid19-ScottishCensusData' repo \ndispersal_dist Average dispersal distance of virus per disease category 2.0km per infectious disease category Guess Varies depending on grid size\nmean_pref Mean temperature preference of virus 298K Guess Currently tuned to fit environment perfectly\nvar_pref Temperature niche width of virus 0.1K Guess Currently tuned to fit environment perfectly\nbirth Probability of giving birth per individual 1.3e-4/day (20-40 year olds), 0 otherwise Guess \ndeath Probability of giving natural mortality per individual 2.7e-5/day Guess \nvirusgrowthasymp Rate of generating virus per asymptomatic individual 0.1/day Guess \nvirusgrowthsymp Rate of generating virus per symptomatic individual 0.1/day Guess \nbeta_force Force of infection 10.0/day Guess \nbeta_env Environmental transmission 10.0/day Guess ","category":"page"},{"location":"diversity/#Integration-with-Diversity.jl","page":"Diversity","title":"Integration with Diversity.jl","text":"","category":"section"},{"location":"diversity/","page":"Diversity","title":"Diversity","text":"Simulation is integrated with the Diversity package, so that diversity measures can be calculated directly on ecosystems.","category":"page"},{"location":"diversity/","page":"Diversity","title":"Diversity","text":"See Basics for more information on setting up an Ecosystem.","category":"page"},{"location":"diversity/","page":"Diversity","title":"Diversity","text":"using Diversity\n# Subcommunity measures\nnorm_sub_alpha(eco, 1.0)\n# Or metacommunity measures\nnorm_meta_alpha(eco, 1.0)\n# Or multiple values of q\nnorm_sub_beta(eco, 0.0:3.0)","category":"page"},{"location":"HPC/#Running-on-DiRAC","page":"HPC","title":"Running on DiRAC","text":"","category":"section"},{"location":"HPC/","page":"HPC","title":"HPC","text":"In order to run EcoSISTEM.jl on DiRAC, it is first necessary to request an account and then to request access to the dc003 project. Once that is granted, it is possible to log into the server via ssh at the address","category":"page"},{"location":"HPC/","page":"HPC","title":"HPC","text":"login.hpc.cam.ac.uk","category":"page"},{"location":"HPC/","page":"HPC","title":"HPC","text":"Julia is already installed on the cluster, so the only things that are needed are a Project.toml file and a Julia script defining and setting up the environment for the experiment, a Julia script with the experiment, and a submission script. Here we give examples using the Scottish experiment. The other files needed for this experiment can be found here","category":"page"},{"location":"HPC/#Project.toml","page":"HPC","title":"Project.toml","text":"","category":"section"},{"location":"HPC/","page":"HPC","title":"HPC","text":"This file should be enough to setup the environment for the experiment. Thus, it should change depending on the packages required by the experiment script. E.g.:","category":"page"},{"location":"HPC/","page":"HPC","title":"HPC","text":"name = \"RAMP\"\n\n[deps]\nAxisArrays = \"39de3d68-74b9-583c-8d2d-e117c070f3a9\"\nDistributions = \"31c24e10-a181-5473-b8eb-7969acd0382f\"\nHTTP = \"cd3eb016-35fb-5094-929b-558a96fad6f3\"\nPlots = \"91a5bcdd-55d7-5caf-9e0b-520d859cae80\"\nStatsBase = \"2913bbd2-ae8a-5f71-8c99-4fb6c76f3a91\"\nUnitful = \"1986cc42-f94f-5a68-af5c-568840ba703d\"\n\n[compat]\njulia = \"1.1\"\n\n[extras]\n\n[targets]","category":"page"},{"location":"HPC/","page":"HPC","title":"HPC","text":"This file should not include EcoSISTEM.jl, as it is unregistered. This will be taken care of by the setup script.","category":"page"},{"location":"HPC/#Setup-script","page":"HPC","title":"Setup script","text":"","category":"section"},{"location":"HPC/","page":"HPC","title":"HPC","text":"This file is responsible for cloning EcoSISTEM.jl, as it is unregistered, and also for instantiating the environment.","category":"page"},{"location":"HPC/","page":"HPC","title":"HPC","text":"using Pkg\nPkg.add(PackageSpec(url=\"https://github.com/ScottishCovidResponse/EcoSISTEM.jl.git\"))\nPkg.instantiate()","category":"page"},{"location":"HPC/#Experiment-script","page":"HPC","title":"Experiment script","text":"","category":"section"},{"location":"HPC/","page":"HPC","title":"HPC","text":"This file should contain the experiment to be run. There are examples available.","category":"page"},{"location":"HPC/#Submission-script","page":"HPC","title":"Submission script","text":"","category":"section"},{"location":"HPC/","page":"HPC","title":"HPC","text":"This file parses options, sets up the local directories and submits the job to the queue.","category":"page"},{"location":"HPC/","page":"HPC","title":"HPC","text":"#!/bin/bash\n\n# Usage: ./submit_scot --input <scriptfilename> --nprocs <numberofprocesses> --walltime <walltime> --dir <pathtorundir>\n\nset -e\nset -u\n\nwhile [ $# -gt 0 ]; do\n    if [ $1 = \"--input\" ]; then\n        inputfile=$2\n        shift 2\n    elif [ $1 == \"--samples\" ]; then\n        nsamples=$2\n        shift 2\n    elif [ $1 == \"--dir\" ]; then\n        dir=$2\n        shift 2\n    elif [ $1 == \"--nprocs\" ]; then\n        nprocs=$2\n        shift 2\n    elif [ $1 == \"--walltime\" ]; then\n        walltime=$2\n        shift 2\n    else\n        echo \"Unrecognised arguments: $*\" >&2\n        exit 1\n    fi\ndone\n\njobname=$(basename $dir)\n\nmkdir $dir\nmkdir $dir/Output\ncp $inputfile $dir\ncp Project.toml $dir\ncp setup.jl $dir\ninputbasename=$(basename $inputfile)\n\ncat >$dir/submit.sh <<EOF\n#!/bin/bash\n#SBATCH --job-name $jobname\n#SBATCH --account DIRAC-DC003-CPU\n#SBATCH --ntasks $nprocs\n#SBATCH --time $walltime\n#SBATCH --mail-type ALL\n#SBATCH --no-requeue\n#SBATCH --partition skylake\n#SBATCH --output log.txt\n. /etc/profile.d/modules.sh\nmodule purge\nmodule load rhel7/default-peta4\nmodule load julia/1.4\nexport JULIA_NUM_THREADS=$nprocs\nstdbuf -oL -eL julia --project=@. setup.jl\nstdbuf -oL -eL julia --project=@. $inputbasename\nEOF\n\ncd $dir\nchmod u+x submit.sh\nsbatch submit.sh","category":"page"},{"location":"HPC/","page":"HPC","title":"HPC","text":"Usage example:","category":"page"},{"location":"HPC/","page":"HPC","title":"HPC","text":"./submit_scot --input Scotland_run.jl --nprocs 6 --walltime 1:00:00 --dir /home/username/run1","category":"page"},{"location":"HPC/","page":"HPC","title":"HPC","text":"The command above must be run from the directory where submit_scot, Scotland_run.jl (the experiment script in this case), setup.jl and Project.toml are. These will be copied to a new folder at the provided path, /home/username/run1. At that path, a log.txt file will contain the logs of the job. The mail-type ALL option makes it such that an email is sent informing of the conclusion of the job, and it can be changed or removed.","category":"page"},{"location":"HPC/#Further-resources","page":"HPC","title":"Further resources","text":"","category":"section"},{"location":"HPC/","page":"HPC","title":"HPC","text":"More detailed information on the cluster, including further options and commands, can be found here.","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we describe several properties that the model ecosystem should be able to recreate, namely:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Species are more abundant when more resources are available to them.\nSpecies' abundances scale with area and are invariant to grid size.\nSpecies with larger average dispersal distances can move further and faster across the landscape.\nSpecies have a competitive advantage when their niche preference is close to that of the climate.\nSpecialist species with a narrow niche width have a competitive advantage over generalists with a broad niche width, for the same niche preference.\nLarge numbers of species are sustained over large areas.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"What follows are several examples of this operating in practice.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using EcoSISTEM\nusing EcoSISTEM.Units\nusing Unitful\nusing Unitful.DefaultSymbols\nusing Diversity\nusing JLD\nusing OnlineStats\nusing Plots\nusing Distributions\nusing Diversity\nplotlyjs()","category":"page"},{"location":"examples/#.-Different-niche-preferences-and-widths","page":"Examples","title":"1. Different niche preferences and widths","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we compare the abundances of species with different temperature preferences and tolerances. On a small patch,we explored the abundance of species given different niche preferences, with all other parameters kept equal. We found that species with niche preference nearer to the 25°C optimum were more abundant, when all species were given the same niche widths. Additionally, when all species had a preference for the 25°C climate and a range of niche widths, those with broader niche widths (generalists) were less abundant than species with narrow (specialists). If the temperature in the ecosystem was then increased by 1°C, those with the narrowest niches went extinct, and the generalists became more abundant, with a preference for those with a niche width of around 1°C as we would expect.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"numSpecies = 100; grd = (10,10); req=(450000.0kJ/m^2, 192.0nm/m^2);\nindividuals = 100_000_000; area = 100.0*km^2;\ntotalK = (4.5e11kJ/km^2, 192.0mm/km^2)\n\nabenv1 = simplehabitatAE(298.0K, grd, totalK[1], area)\nabenv2 = simplehabitatAE(298.0K, grd, totalK[2], area)\nbud = BudgetCollection2(abenv1.budget, abenv2.budget)\nabenv = GridAbioticEnv{typeof(abenv1.habitat), typeof(bud)}(abenv1.habitat, abenv1.active, bud, abenv1.names)\n\nvars = fill(2.0, numSpecies) .* K\nopts = 298.0K .+ vars .* range(-3, stop = 3, length = numSpecies)\n\nav_dist = fill(2.4, numSpecies) .* km\nkernel = GaussianKernel.(av_dist, 10e-10)\n\ndeath = 0.15/ year\nbirth = death\nl = 1.0\ns = 0.1\nboost = 1.0\n\nsize_mean = 1.0m^2\n# Set up how much energy each species consumes\nenergy_vec1 = SolarRequirement(fill(req[1] * size_mean, numSpecies))\nenergy_vec2 = WaterRequirement(fill(req[2] * size_mean, numSpecies))\n\nenergy_vec = ReqCollection2(energy_vec1, energy_vec2)\nparam = EqualPop(birth, death, l, s , boost)\n\n# Create ecosystem\n\nmovement = BirthOnlyMovement(kernel, Torus())\n\ntraits = GaussTrait(opts, vars)\nnative = fill(true, numSpecies)\nabun = rand(Multinomial(individuals, numSpecies))\nsppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n    movement, param, native)\nrel = Gauss{typeof(first(opts))}()\neco = Ecosystem(sppl, abenv, rel)\n\ntimes = 10years; timestep = 1month\nlensim = length(0month:timestep:times)\n\nsimulate!(eco, times, timestep)\nendabun = eco.abundances.matrix\ntemps = map(eachindex(opts)) do i\n    repeat([opts[i]], endabun[i])\nend\n\ntemps = vcat(temps...)\nedges = collect(292.0:1:304) .* K\nh = Hist(edges)\nfit!(h, temps)\nbar(ustrip.(uconvert.(°C, edges)), h.counts,\ngrid = false, xlab = \"Temperature preference (°C)\",\nylab = \"Abundance\",\nguidefontsize = 16, tickfontsize= 16, size = (1200, 1000),\ntitlefontsize = 16, title = \"A\", titleloc = :left,\nmargin = 10.0*Plots.mm, label = \"\", layout = (@layout[a; b c]))\n\n## DIFFERENT VARS ##\n\nnumSpecies = 100; grd = (10,10); req=(450000.0kJ/m^2, 192.0nm/m^2);\nindividuals = 100_000_000; area = 100.0*km^2;\ntotalK = (4.5e11kJ/km^2, 192.0mm/km^2)\n\nabenv1 = simplehabitatAE(298.0K, grd, totalK[1], area)\nabenv2 = simplehabitatAE(298.0K, grd, totalK[2], area)\nbud = BudgetCollection2(abenv1.budget, abenv2.budget)\nabenv = GridAbioticEnv{typeof(abenv1.habitat), typeof(bud)}(abenv1.habitat, abenv1.active, bud, abenv1.names)\n\nvars = range(0.0001, stop = 5, length = numSpecies) .* K\nopts = fill(298.0K, numSpecies)\n\nav_dist = fill(2.4, numSpecies) .* km\nkernel = GaussianKernel.(av_dist, 10e-10)\n\ndeath = 0.15/ year\nbirth = death\nl = 1.0\ns = 0.1\nboost = 1.0\n\nsize_mean = 1.0m^2\n# Set up how much energy each species consumes\nenergy_vec1 = SolarRequirement(fill(req[1] * size_mean, numSpecies))\nenergy_vec2 = WaterRequirement(fill(req[2] * size_mean, numSpecies))\n\nenergy_vec = ReqCollection2(energy_vec1, energy_vec2)\nparam = EqualPop(birth, death, l, s , boost)\n\n# Create ecosystem\n\nmovement = BirthOnlyMovement(kernel, Torus())\n\ntraits = GaussTrait(opts, vars)\nnative = fill(true, numSpecies)\nabun = rand(Multinomial(individuals, numSpecies))\nsppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n    movement, param, native)\nrel = Gauss{typeof(first(opts))}()\neco = Ecosystem(sppl, abenv, rel)\n\ntimes = 10years; timestep = 1month\nlensim = length(0month:timestep:times)\n\nsimulate!(eco, times, timestep)\nendabun = eco.abundances.matrix\nwidths = map(eachindex(vars)) do i\n    repeat([vars[i]], endabun[i])\nend\nwidths = vcat(widths...)\nedges = collect(0.1:0.2:5) .* K\nh = Hist(edges)\nfit!(h, widths)\nbar!(edges./K, h.counts, grid = false,\nxlab = \"Niche width (°C)\", ylab = \"Abundance\",\nguidefontsize = 16, tickfontsize= 16, titlefontsize = 16,\nmargin = 10.0*Plots.mm, left_margin = 20.0 * Plots.mm, label = \"\",\nsubplot = 2,\ntitle = \"B\", titleloc = :left, ylim = (0, 32_000))\n\n## DIFFERENT VARS MISMATCH ##\nnumSpecies = 100; grd = (10,10); req=(450000.0kJ/m^2, 192.0nm/m^2);\nindividuals = 100_000_000; area = 100.0*km^2;\ntotalK = (4.5e11kJ/km^2, 192.0mm/km^2)\n\nabenv1 = simplehabitatAE(299.0K, grd, totalK[1], area)\nabenv2 = simplehabitatAE(299.0K, grd, totalK[2], area)\nbud = BudgetCollection2(abenv1.budget, abenv2.budget)\nabenv = GridAbioticEnv{typeof(abenv1.habitat), typeof(bud)}(abenv1.habitat, abenv1.active, bud, abenv1.names)\n\nvars = range(0.0001, stop = 5, length = numSpecies) .* K\nopts = fill(298.0K, numSpecies)\n\nav_dist = fill(2.4, numSpecies) .* km\nkernel = GaussianKernel.(av_dist, 10e-10)\n\ndeath = 0.15/ year\nbirth = death\nl = 1.0\ns = 0.1\nboost = 1.0\n\nsize_mean = 1.0m^2\n# Set up how much energy each species consumes\nenergy_vec1 = SolarRequirement(fill(req[1] * size_mean, numSpecies))\nenergy_vec2 = WaterRequirement(fill(req[2] * size_mean, numSpecies))\n\nenergy_vec = ReqCollection2(energy_vec1, energy_vec2)\nparam = EqualPop(birth, death, l, s , boost)\n\n# Create ecosystem\n\nmovement = BirthOnlyMovement(kernel, Torus())\n\ntraits = GaussTrait(opts, vars)\nnative = fill(true, numSpecies)\nabun = rand(Multinomial(individuals, numSpecies))\nsppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n    movement, param, native)\nrel = Gauss{typeof(first(opts))}()\neco = Ecosystem(sppl, abenv, rel)\n\ntimes = 10years; timestep = 1month\nlensim = length(0month:timestep:times)\n\nsimulate!(eco, times, timestep)\nendabun = eco.abundances.matrix\nwidths = map(eachindex(vars)) do i\n    repeat([vars[i]], endabun[i])\nend\nwidths = vcat(widths...)\nedges = collect(0.1:0.2:5) .* K\nh = Hist(edges)\nfit!(h, widths)\nbar!(edges./K, h.counts, grid = false,\nxlab = \"Niche width (°C)\", ylab = \"\",\nguidefontsize = 16, tickfontsize= 16, titlefontsize = 16,\nmargin = 10.0*Plots.mm, label = \"\", subplot = 3,\ntitle = \"C\", titleloc = :left, ylim = (0, 32_000))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) Abundance of species across 100km² patch ecosystem with 100 species, (A) with a different temperature preferences and a homogeneous climate of 25°C, (B)  with different niche widths and a temperature preference for 25°C and (C) different niche widths with a shifted homogeneous climate of 26°C.","category":"page"},{"location":"examples/#.-Varying-resources,-grid-sizes,-areas-and-number-of-species","page":"Examples","title":"2. Varying resources, grid sizes, areas and number of species","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Firstly, we confirmed that abundance depended upon the amount of available resource. Here, we simulated an island ecosystem with two resources, water and sunlight, each on a gradient West to East and South to North, respectively. All species were seeded with the same resource requirements and vital rates. Abundance increased in squares with greater amounts of water and sunlight, with some edge effects. Next, we investigated the relationship between abundance and area size. As expected, ecosystems with greater areas could support more individuals, and these abundances were invariant to the resolution of the grid. We also tested in an ecosystem in which species demographic and dispersal rates and resource requirements varied. Under these circumstances, some species not favoured for the conditions go extinct, but most species survive to the end of the simulation.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"## MORE ENERGY MORE ABUNDANCE ##\nnumSpecies = 100; grd = (10,10); req=(450000.0kJ/m^2, 192.0nm/m^2); individuals = 100_000_000; area = 100.0*km^2; totalK = (4.5e11kJ/km^2, 192.0mm/km^2)\n\nabenv1 = simplehabitatAE(298.0K, grd, totalK[1], area)\nabenv2 = simplehabitatAE(298.0K, grd, totalK[2], area)\nbud = BudgetCollection2(abenv1.budget, abenv2.budget)\nabenv = GridAbioticEnv{typeof(abenv1.habitat), typeof(bud)}(abenv1.habitat, abenv1.active, bud, abenv1.names)\ngsize = size(abenv.budget.b1.matrix, 1)\nsol_range = collect(range(0.0kJ, stop = 4.5e11kJ, length = gsize))\n map(1:gsize) do seq\n   abenv.budget.b1.matrix[seq, :] .= sol_range[seq]\n end\nabenv.budget.b1.matrix\n\ngsize = size(abenv.budget.b2.matrix, 1)\nwater_range = collect(range(0.0mm, stop = 192mm, length = gsize))\nmap(1:gsize) do seq\n    abenv.budget.b2.matrix[:, seq] .= water_range[seq]\nend\nabenv.budget.b2.matrix\n\nvars = fill(2.0, numSpecies) .* K\nopts = fill(298.0, numSpecies) .* K\nav_dist = fill(2.4, numSpecies) .* km\nkernel = GaussianKernel.(av_dist, 10e-10)\n\ndeath = 0.15/ year\nbirth = death\nl = 1.0\ns = 0.1\nboost = 1.0\n\nsize_mean = 1.0m^2\n# Set up how much energy each species consumes\nenergy_vec1 = SolarRequirement(fill(req[1] * size_mean, numSpecies))\nenergy_vec2 = WaterRequirement(fill(req[2] * size_mean, numSpecies))\n\nenergy_vec = ReqCollection2(energy_vec1, energy_vec2)\nparam = EqualPop(birth, death, l, s , boost)\n\n# Create ecosystem\n\nmovement = BirthOnlyMovement(kernel, NoBoundary())\n\ntraits = GaussTrait(opts, vars)\nnative = fill(true, numSpecies)\nabun = rand(Multinomial(individuals, numSpecies))\nsppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n    movement, param, native)\nrel = Gauss{typeof(first(opts))}()\neco = Ecosystem(sppl, abenv, rel)\n\ntimes = 10years; timestep = 1month\nlensim = length(0month:timestep:times)\n\nsimulate!(eco, times, timestep)\nendabun = sum(eco.abundances.matrix, dims = 1)\nendabun = reshape(endabun, 10, 10)\n\nheatmap(sol_range./kJ, water_range./mm, endabun, grid = false,\n xlab = \"Solar energy\", ylab = \"Water\", size = (1600, 1200),\nguidefontsize = 16, tickfontsize= 16, titlefontsize=24,\nmargin = 10.0*Plots.mm, legendfontsize = 16, label = \"\", left_margin = 20.0 * Plots.mm,\nlayout = (@layout [a b; c d]), title = \"A\", titleloc = :left)\n\n\n\n## INVARIANT TO GRID SIZE ##\ntimes = 10years; timestep = 1month\nlensim = length(0month:timestep:times)\nendabuns = zeros(Int64, 4)\ngrids = [1,2,5,10]\nfor i in eachindex(grids)\n    numSpecies = 100; grd = (grids[i],grids[i]); req=(450000.0kJ/m^2, 192.0nm/m^2);\n    individuals = 100_000_000; area = 100.0*km^2;\n    totalK = (4.5e11kJ/km^2, 192.0mm/km^2)\n\n    abenv1 = simplehabitatAE(298.0K, grd, totalK[1], area)\n    abenv2 = simplehabitatAE(298.0K, grd, totalK[2], area)\n    bud = BudgetCollection2(abenv1.budget, abenv2.budget)\n    abenv = GridAbioticEnv{typeof(abenv1.habitat), typeof(bud)}(abenv1.habitat, abenv1.active, bud, abenv1.names)\n\n    vars = fill(2.0, numSpecies) .* K\n    opts = fill(298.0, numSpecies) .* K\n    av_dist = fill(2.4, numSpecies) .* km\n    kernel = GaussianKernel.(av_dist, 10e-10)\n\n    death = 0.15/ year\n    birth = death\n    l = 1.0\n    s = 0.1\n    boost = 1.0\n\n    size_mean = 1.0m^2\n    # Set up how much energy each species consumes\n    energy_vec1 = SolarRequirement(fill(req[1] * size_mean, numSpecies))\n    energy_vec2 = WaterRequirement(fill(req[2] * size_mean, numSpecies))\n\n    energy_vec = ReqCollection2(energy_vec1, energy_vec2)\n    param = EqualPop(birth, death, l, s , boost)\n\n    # Create ecosystem\n\n    movement = BirthOnlyMovement(kernel, NoBoundary())\n\n    traits = GaussTrait(opts, vars)\n    native = fill(true, numSpecies)\n    abun = rand(Multinomial(individuals, numSpecies))\n    sppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n        movement, param, native)\n    rel = Gauss{typeof(first(opts))}()\n    eco = Ecosystem(sppl, abenv, rel)\n    simulate!(eco, times, timestep)\n    endabuns[i] = sum(eco.abundances.matrix)\nend\n\nbar!(string.(grids), endabuns,\ngrid = false, xlab = \"Number of grid squares\",\nylab = \"Total abundance\",\nguidefontsize = 16,tickfontsize= 16, titlefontsize=24,\nmargin = 10.0*Plots.mm, label = \"\", left_margin = 20.0 * Plots.mm,\nsubplot = 2, title = \"B\", titleloc = :left)\n\n## ABUNDANCE SCALES WITH AREA ##\ntimes = 10years; timestep = 1month\nlensim = length(0month:timestep:times)\nendabuns = zeros(Int64, 4)\nareas = [10.0,20.0,50.0,100.0]\nfor i in eachindex(areas)\n    numSpecies = 100; grd = (10,10); req=(450000.0kJ/m^2, 192.0nm/m^2);\n    individuals = 100_000_000; area = areas[i].*km^2;\n    totalK = (4.5e11kJ/km^2, 192.0mm/km^2)\n\n    abenv1 = simplehabitatAE(298.0K, grd, totalK[1], area)\n    abenv2 = simplehabitatAE(298.0K, grd, totalK[2], area)\n    bud = BudgetCollection2(abenv1.budget, abenv2.budget)\n    abenv = GridAbioticEnv{typeof(abenv1.habitat), typeof(bud)}(abenv1.habitat, abenv1.active, bud, abenv1.names)\n\n    vars = fill(2.0, numSpecies) .* K\n    opts = fill(298.0, numSpecies) .* K\n    av_dist = fill(2.4, numSpecies) .* km\n    kernel = GaussianKernel.(av_dist, 10e-10)\n\n    death = 0.15/ year\n    birth = death\n    l = 1.0\n    s = 0.1\n    boost = 1.0\n\n    size_mean = 1.0m^2\n    # Set up how much energy each species consumes\n    energy_vec1 = SolarRequirement(fill(req[1] * size_mean, numSpecies))\n    energy_vec2 = WaterRequirement(fill(req[2] * size_mean, numSpecies))\n\n    energy_vec = ReqCollection2(energy_vec1, energy_vec2)\n    param = EqualPop(birth, death, l, s , boost)\n\n    # Create ecosystem\n\n    movement = BirthOnlyMovement(kernel, NoBoundary())\n\n    traits = GaussTrait(opts, vars)\n    native = fill(true, numSpecies)\n    abun = rand(Multinomial(individuals, numSpecies))\n    sppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n        movement, param, native)\n    rel = Gauss{typeof(first(opts))}()\n    eco = Ecosystem(sppl, abenv, rel)\n    simulate!(eco, times, timestep)\n    endabuns[i] = sum(eco.abundances.matrix)\nend\n\nbar!(string.(areas), endabuns, grid = false, xlab = \"Area (km²)\",\nylab = \"Total abundance\", guidefontsize = 16,\ntickfontsize= 16, titlefontsize=24, margin = 10.0*Plots.mm,\nlabel = \"\", subplot = 3, title = \"C\", titleloc = :left,\nleft_margin = 20.0 *Plots.mm)\n\n## Sustain large number of species ##\ntimes = 10years; timestep = 1month\nlensim = length(0month:timestep:times)\nreps = 10\nspecies = [100, 500, 1_000, 5_000]\nSR = zeros(Float64, length(species), reps)\nfor r in 1:reps\n    for i in eachindex(species)\n        numSpecies = species[i]; grd = (10,10); req=(450000.0kJ/m^2, 192.0nm/m^2);\n        individuals = 100_000_000; area = 100.0km^2;\n        totalK = (4.5e11kJ/km^2, 192.0mm/km^2)\n\n        abenv1 = simplehabitatAE(298.0K, grd, totalK[1], area)\n        abenv2 = simplehabitatAE(298.0K, grd, totalK[2], area)\n        bud = BudgetCollection2(abenv1.budget, abenv2.budget)\n        abenv = GridAbioticEnv{typeof(abenv1.habitat), typeof(bud)}(abenv1.habitat, abenv1.active, bud, abenv1.names)\n\n        vars = rand(Uniform(1.0, 5.0), numSpecies) .* K\n        opts = 298.0K .+ vars .* range(-3, stop = 3, length = numSpecies)\n        av_dist = rand(Uniform(0.6, 2.4), numSpecies) .* km\n        kernel = GaussianKernel.(av_dist, 10e-10)\n\n        death = abs.(rand(Normal(0.15, 0.135), numSpecies)) ./year\n        birth = death\n        l = 1.0\n        s = 0.1\n        boost = 1.0\n\n        size_mean = rand(Normal(1.0, 0.5), numSpecies) .* m^2\n        # Set up how much energy each species consumes\n        energy_vec1 = SolarRequirement(abs.(req[1] .* size_mean))\n        energy_vec2 = WaterRequirement(abs.(req[2] .* size_mean))\n\n        energy_vec = ReqCollection2(energy_vec1, energy_vec2)\n        param = PopGrowth{typeof(unit(birth[1]))}(birth, death, l, s , boost)\n\n        # Create ecosystem\n\n        movement = BirthOnlyMovement(kernel, NoBoundary())\n\n        traits = GaussTrait(opts, vars)\n        native = fill(true, numSpecies)\n        abun = rand(Multinomial(individuals, numSpecies))\n        sppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n            movement, param, native)\n        rel = Gauss{typeof(first(opts))}()\n        eco = Ecosystem(sppl, abenv, rel)\n        simulate!(eco, times, timestep)\n        SR[i, r] = sum(sum(eco.abundances.matrix, dims = 2) .> 0)\n        print(\".\")\n    end\nend\n\nmeanSR = dropdims(mean(SR, dims = 2), dims = 2)\nsdSR = dropdims(std(SR, dims = 2), dims = 2)\n\nbar!(string.(species), meanSR ./species, yerr= sdSR ./ species, grid = false, xlab = \"Number of species introduced\",\nylab = \"% Species survived\", guidefontsize = 16,\ntickfontsize= 16, titlefontsize=24, margin = 10.0*Plots.mm,\nlabel = \"\",  title = \"D\", subplot = 4, titleloc = :left,\nleft_margin = 20.0 *Plots.mm, ylim = (0, 1))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) Model testing on island ecosystems. (A) Total abundance of 100 species, with varying resources of water and solar energy across the grid. (B) Total abundance of 100 species, with increasing area size. (C) Total abundance of 100 species, with increasing grid square resolution. (D) Percentage of species survived after 10 years of simulation.","category":"page"},{"location":"examples/#.-Dispersal","page":"Examples","title":"3. Dispersal","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finally, we verify that dispersal is functioning as expected. This figure shows the overall abundance of an island populated with two species at opposite extremes of the ecosystem after ten years of simulation. The species moved faster and further into the unpopulated island centre when they had higher average dispersal distances, though again with some edge effects.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"times = 50years; timestep = 1month\nlensim = length(0month:timestep:times)\ndistances = [0.5, 1.0, 2.0, 4.0]\nendabuns = zeros(Int64, 10, 10, length(distances))\nfor i in eachindex(distances)\n    numSpecies = 2; grd = (10,10); req=(450000.0kJ/m^2, 192.0nm/m^2);\n    individuals = 0; area = 100.0km^2;\n    totalK = (4.5e11kJ/km^2, 192.0mm/km^2)\n\n    abenv1 = simplehabitatAE(298.0K, grd, totalK[1], area)\n    abenv2 = simplehabitatAE(298.0K, grd, totalK[2], area)\n    bud = BudgetCollection2(abenv1.budget, abenv2.budget)\n    abenv = GridAbioticEnv{typeof(abenv1.habitat), typeof(bud)}(abenv1.habitat, abenv1.active, bud, abenv1.names)\n\n    vars = fill(2.0, numSpecies) .* K\n    opts = fill(298.0, numSpecies) .* K\n    av_dist = fill(distances[i], numSpecies) .* km\n    kernel = GaussianKernel.(av_dist, 10e-10)\n\n    death = 0.15/ year\n    birth = death\n    l = 1.0\n    s = 0.1\n    boost = 1.0\n\n    size_mean = 1.0m^2\n    # Set up how much energy each species consumes\n    energy_vec1 = SolarRequirement(fill(req[1] * size_mean, numSpecies))\n    energy_vec2 = WaterRequirement(fill(req[2] * size_mean, numSpecies))\n\n    energy_vec = ReqCollection2(energy_vec1, energy_vec2)\n    param = EqualPop(birth, death, l, s , boost)\n\n    # Create ecosystem\n\n    movement = BirthOnlyMovement(kernel, NoBoundary())\n\n    traits = GaussTrait(opts, vars)\n    native = fill(true, numSpecies)\n    abun = rand(Multinomial(individuals, numSpecies))\n    sppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n        movement, param, native)\n    rel = Gauss{typeof(first(opts))}()\n    eco = Ecosystem(sppl, abenv, rel)\n    eco.abundances.grid[1, :, 1] .= 100.0\n    eco.abundances.grid[2, :, 10] .= 100.0\n    simulate!(eco, times, timestep)\n    endabuns[:, :, i] = sum(eco.abundances.matrix, dims = 1)\nend\n\nheatmap(grid = false, xlab = \"Distance (km)\",\nylab = \"Distance (km)\", size = (1200, 800),\nguidefontsize = 12,tickfontsize= 12, titlefontsize=18,\nmargin = 10.0*Plots.mm, legendfontsize = 12, label = \"\",\nlayout = (@layout [a b; c d]), link = :both)\ntitles = [\"A\", \"B\", \"C\", \"D\"]\nfor i in 1:4\n    m = distances[i]\n    display(heatmap!(1:10,1:10, endabuns[:, :, i],\n    grid = false, xlab = \"Distance (km)\", ylab = \"Distance (km)\",\n    guidefontsize = 16, tickfontsize= 16,\n    titlefontsize=24, title = titles[i], margin = 10.0*Plots.mm,\n    label = \"\", subplot = i, titleloc = :left,\n    clim = (0, 1.5e4), link = :both))\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) Total abundance of two species in island ecosystems after 10 years of simulation, with species populated at opposite sides of the island. Those with higher dispersal distances moved further away from their starting populations at a faster rate. (A) Mean dispersal distance of 0.5km, (B) mean dispersal distance of 1km, (C) Mean dispersal distance of 2km, Mean dispersal distance of 4km.","category":"page"},{"location":"#EcoSISTEM.jl","page":"Home","title":"EcoSISTEM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EcoSISTEM (Ecosystem Simulation through Species-Trait Environment Modelling) is a Julia package that provides functionality for simulating species undergoing dynamic biological processes such as birth, death, competition and dispersal, as well as environmental changes in climate and habitat. This repo has now been adapted to include basic functionality for spatially explicit, dynamic, stochastic SIR and other compartmental models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package was primarily developed for global scale simulations of plant biodiversity. The underlying model for this is described in the arXiv paper arXiv:1911.12257 (q-bio.QM) Dynamic virtual ecosystems as a tool for detecting large-scale responses of biodiversity to environmental and land-use change. Future updates to the package functionality involve incorporating age-structure and more complex epidemiological models.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is in alpha now, so please raise an issue if you find any problems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"}]
}
