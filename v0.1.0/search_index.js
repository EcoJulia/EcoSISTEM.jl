var documenterSearchIndex = {"docs":
[{"location":"africa/#Virtual-plant-simulations-of-Africa","page":"Africa","title":"Virtual plant simulations of Africa","text":"","category":"section"},{"location":"africa/","page":"Africa","title":"Africa","text":"EcoSISTEM was designed to scale to much larger areas, supporting many more species. As an illustrative example, here we simulate up to 50,000 plant species over Africa at an 80km grid scale, with a constant background environment of 25°C. When all species are given an equal fitness in the habitat, all 50,000 can co-exist over long time scales of over 100 years (Figure 2A). This can be run on a workstation with 24 threads in just under 5 hours.","category":"page"},{"location":"africa/","page":"Africa","title":"Africa","text":"We can also explore the behaviour of selective advantage of specialist species over generalists at these scales. When we introduce a specialist species into an African-sized landscape with an existing generalist, the specialist out-competes the generalist and spreads throughout the continent. The larger the selective advantage of the specialist, the faster it is able to invade and colonise across the landscape (Figure 1). These same dynamics can be seen when we introduce a specialist to the full complement of 50,000 species (Figure 1B-D).","category":"page"},{"location":"africa/#SINGLE-SPECIES","page":"Africa","title":"SINGLE SPECIES","text":"","category":"section"},{"location":"africa/","page":"Africa","title":"Africa","text":"using EcoSISTEM\nusing EcoSISTEM.ClimatePref\nusing EcoSISTEM.Units\nusing Unitful\nusing Unitful.DefaultSymbols\nusing Distances\nusing StatsBase\nusing Plots\nfile = \"Africa.tif\"\nafrica = readfile(file, -25°, 50°, -35°, 40°)\nactive =  Array{Bool, 2}(.!isnan.(africa'))\n\nheatmap(active)\n\n# Set up initial parameters for ecosystem\nnumSpecies = 1; grid = size(africa); req= 10.0kJ; individuals=0; area = 64e6km^2; totalK = 1000.0kJ/km^2\n\n# Set up how much energy each species consumes\nenergy_vec = SolarRequirement(fill(req, numSpecies))\n\n\n# Set rates for birth and death\nbirth = 0.6/year\ndeath = 0.6/year\nlongevity = 1.0\nsurvival = 0.0\nboost = 1.0\n# Collect model parameters together\nparam = EqualPop(birth, death, longevity, survival, boost)\n\n# Create kernel for movement\nkernel = fill(GaussianKernel(15.0km, 10e-10), numSpecies)\nmovement = AlwaysMovement(kernel, Torus())\n\n\n# Create species list, including their temperature preferences, seed abundance and native status\nopts = fill(274.0K, numSpecies)\nvars = fill(0.5K, numSpecies)\ntraits = GaussTrait(opts, vars)\nnative = fill(true, numSpecies)\n# abun = rand(Multinomial(individuals, numSpecies))\nabun = fill(div(individuals, numSpecies), numSpecies)\nsppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n    movement, param, native)\nsppl.params.birth\n\n# Create abiotic environment - even grid of one temperature\nabenv = simplehabitatAE(274.0K, grid, totalK, area, active)\n\n\n# Set relationship between species and environment (gaussian)\nrel = Gauss{typeof(1.0K)}()\n\n#Create ecosystem\neco = Ecosystem(sppl, abenv, rel)\nrand_start = rand(findall(active), 1)[1]\neco.abundances.grid[1, rand_start[1], rand_start[2]] = 100\n\n# EcoSISTEM Parameters\ntimes = 100years; timestep = 1month; record_interval = 1month; repeats = 1\nlensim = length(0years:record_interval:times)\nabuns = zeros(Int64, numSpecies, prod(grid), lensim)\n@time simulate_record!(abuns, eco, times, record_interval, timestep);\n\nabuns = reshape(abuns[1, :, :, 1], grid[1], grid[2], lensim)\n\nanim = @animate for i in 1:lensim\n    africa_abun = Float64.(abuns[:, :, i])\n    africa_abun[.!(active)] .= NaN\n    heatmap(africa_abun, clim = (0, 700_000), background_color = :lightblue, background_color_outside=:white, grid = false, color = cgrad(:algae, scale = :exp), aspect_ratio = 1)\nend\ngif(anim, \"examples/Biodiversity/Africa.gif\", fps = 30)\n\n#### SPECIALIST VERSUS GENERALIST ####\n\nspecialist_vars = [0.5K, 1.0K, 5.0K, 10.0K, 25.0K, 50.0K]\nvelocity = zeros(typeof(1.0km/month), length(specialist_vars))\nrand_start = rand(findall(active), 1)[1]\nfor i in eachindex(specialist_vars)\n    # Set up initial parameters for ecosystem\n    numSpecies = 2; grid = size(africa); req= 10.0kJ; individuals=0; area = 64e6km^2; totalK = 1000.0kJ/km^2\n\n    # Set up how much energy each species consumes\n    energy_vec = SolarRequirement(fill(req, numSpecies))\n\n\n    # Set rates for birth and death\n    birth = 0.6/year\n    death = 0.6/year\n    longevity = 1.0\n    survival = 0.1\n    boost = 1.0\n    # Collect model parameters together\n    param = EqualPop(birth, death, longevity, survival, boost)\n\n    # Create kernel for movement\n    kernel = fill(GaussianKernel(15.0km, 10e-10), numSpecies)\n    movement = AlwaysMovement(kernel, Torus())\n\n\n    # Create species list, including their temperature preferences, seed abundance and native status\n    opts = fill(274.0K, numSpecies)\n    vars = [50.0K, specialist_vars[i]]\n    traits = GaussTrait(opts, vars)\n    native = fill(true, numSpecies)\n    # abun = rand(Multinomial(individuals, numSpecies))\n    abun = fill(div(individuals, numSpecies), numSpecies)\n    sppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n        movement, param, native)\n    sppl.params.birth\n\n    # Create abiotic environment - even grid of one temperature\n    abenv = simplehabitatAE(274.0K, grid, totalK, area, active)\n\n    # Set relationship between species and environment (gaussian)\n    rel = Gauss{typeof(1.0K)}()\n\n    #Create ecosystem\n    eco = Ecosystem(sppl, abenv, rel)\n    eco.abundances.grid[1, rand_start[1], rand_start[2]] = 100\n\n    # EcoSISTEM Parameters\n    burnin = 100years; times = 100years; timestep = 1month; record_interval = 1month; repeats = 1\n    lensim = length(0years:record_interval:times)\n    simulate!(eco, burnin,timestep)\n    eco.abundances.grid[2, rand_start[1], rand_start[2]] = 100\n    abuns = zeros(Int64, numSpecies, prod(grid), lensim)\n    @time simulate_record!(abuns, eco, times, record_interval, timestep);\n\n    abuns = reshape(abuns[:, :, :, 1], numSpecies, grid[1], grid[2], lensim)\n    origin = [rand_start[1], rand_start[2]]\n    dest = findall(abuns[2, :, :, 1] .> 0)\n    inst_velocity = map(1:lensim) do t\n        dest = findall(abuns[2, :, :, t] .> 0)\n        dists = [euclidean(origin, [dest[i][1], dest[i][2]]) for i in length(dest)] .* getgridsize(eco)\n        return maximum(dists)/month\n    end\n    velocity[i] = mean(inst_velocity)\nend\n\nplot(ustrip.(abs.(specialist_vars .- 50.0K)), ustrip.(velocity),\n    xlab = \"Selective advantage\", ylab = \"Invasion speed (km/month)\",\n    label = \"\", grid = false)","category":"page"},{"location":"africa/","page":"Africa","title":"Africa","text":"(Image: ) Figure 1: Invasive capacity of a specialist plant species versus a generalist. Selective advantage is the difference in niche width between the specialist and generalist, and invasion speed is calculated as the average distance travelled per month by the specialist.","category":"page"},{"location":"africa/#ONE-SPECIALIST-VERSUS-MANY-GENERALISTS","page":"Africa","title":"ONE SPECIALIST VERSUS MANY GENERALISTS","text":"","category":"section"},{"location":"africa/","page":"Africa","title":"Africa","text":"using EcoSISTEM\nusing EcoSISTEM.ClimatePref\nusing EcoSISTEM.Units\nusing Unitful\nusing Unitful.DefaultSymbols\nusing JLD\nusing Printf\nfile = \"Africa.tif\"\nafrica = readfile(file, -25°, 50°, -35°, 40°)\nactive =  Array{Bool, 2}(.!isnan.(africa'))\n# Set up initial parameters for ecosystem\nnumSpecies = 50_000; grid = size(africa); req= 10.0kJ; individuals=3*10^8; area = 64e6km^2; totalK = 1000.0kJ/km^2\n\n# Set up how much energy each species consumes\nenergy_vec = SolarRequirement(fill(req, numSpecies))\n\n\n# Set rates for birth and death\nbirth = 0.6/year\ndeath = 0.6/year\nlongevity = 1.0\nsurvival = 0.1\nboost = 1.0\n# Collect model parameters together\nparam = EqualPop(birth, death, longevity, survival, boost)\n\n# Create kernel for movement\nkernel = fill(GaussianKernel(15.0km, 10e-10), numSpecies)\nmovement = AlwaysMovement(kernel, Torus())\n\n\n# Create species list, including their temperature preferences, seed abundance and native status\nopts = fill(274.0K, numSpecies)\nvars = fill(50.0K, numSpecies)\nvars[50_000] = 0.5K\ntraits = GaussTrait(opts, vars)\nnative = fill(true, numSpecies)\n# abun = rand(Multinomial(individuals, numSpecies))\nabun = fill(div(individuals, numSpecies), numSpecies)\nsppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n    movement, param, native)\nsppl.params.birth\n\n# Create abiotic environment - even grid of one temperature\nabenv = simplehabitatAE(274.0K, grid, totalK, area, active)\n\n\n# Set relationship between species and environment (gaussian)\nrel = Gauss{typeof(1.0K)}()\n\n#Create ecosystem\neco = Ecosystem(sppl, abenv, rel)\neco.abundances.matrix[50_000, :] .= 0\n\nimport EcoSISTEM.simulate!\nfunction simulate!(eco::Ecosystem, times::Unitful.Time, timestep::Unitful.Time, cacheInterval::Unitful.Time, cacheFolder::String, scenario_name::String)\n  time_seq = 0s:timestep:times\n  counting = 0\n  for i in 1:length(time_seq)\n      update!(eco, timestep);\n      # Save cache of abundances\n      if mod(time_seq[i], cacheInterval) == 0year\n          JLD.save(joinpath(cacheFolder, scenario_name * (@sprintf \"%02d.jld\" uconvert(NoUnits,time_seq[i]/cacheInterval))), \"abun\", eco.abundances.matrix)\n      end\n  end\nend\n\n# EcoSISTEM Parameters\nburnin = 100years; times = 100years; timestep = 1month; record_interval = 12months;\nlensim = length(0years:record_interval:times)\n@time simulate!(eco, burnin, timestep)\nrand_start = rand(findall(active), 1)[1]\neco.abundances.grid[50_000, rand_start[1], rand_start[2]] = 100\n@time simulate!(eco, times, timestep, record_interval, \"examples/Biodiversity\", \"Africa_run\");","category":"page"},{"location":"africa/#,000-SPECIES-COEXISTING","page":"Africa","title":"50,000 SPECIES COEXISTING","text":"","category":"section"},{"location":"africa/","page":"Africa","title":"Africa","text":"using EcoSISTEM\nusing EcoSISTEM.ClimatePref\nusing EcoSISTEM.Units\nusing Unitful\nusing Unitful.DefaultSymbols\nusing JLD\nusing Printf\n\nfile = \"Africa.tif\"\nafrica = readfile(file, -25°, 50°, -35°, 40°)\nactive =  Array{Bool, 2}(.!isnan.(africa'))\n# Set up initial parameters for ecosystem\nnumSpecies = 50_000; grid = size(africa); req= 10.0kJ; individuals=3*10^8; area = 64e6km^2; totalK = 1000.0kJ/km^2\n\n# Set up how much energy each species consumes\nenergy_vec = SolarRequirement(fill(req, numSpecies))\n\n\n# Set rates for birth and death\nbirth = 0.6/year\ndeath = 0.6/year\nlongevity = 1.0\nsurvival = 0.1\nboost = 1.0\n# Collect model parameters together\nparam = EqualPop(birth, death, longevity, survival, boost)\n\n# Create kernel for movement\nkernel = fill(GaussianKernel(15.0km, 10e-10), numSpecies)\nmovement = AlwaysMovement(kernel, Torus())\n\n\n# Create species list, including their temperature preferences, seed abundance and native status\nopts = fill(274.0K, numSpecies)\nvars = fill(50.0K, numSpecies)\ntraits = GaussTrait(opts, vars)\nnative = fill(true, numSpecies)\n# abun = rand(Multinomial(individuals, numSpecies))\nabun = fill(div(individuals, numSpecies), numSpecies)\nsppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n    movement, param, native)\nsppl.params.birth\n\n# Create abiotic environment - even grid of one temperature\nabenv = simplehabitatAE(274.0K, grid, totalK, area, active)\n\n\n# Set relationship between species and environment (gaussian)\nrel = Gauss{typeof(1.0K)}()\n\n#Create ecosystem\neco = Ecosystem(sppl, abenv, rel)\n\n# EcoSISTEM Parameters\nburnin = 10years; times = 100years; timestep = 1month; record_interval = 12months;\nlensim = length(0years:record_interval:times)\n@time simulate!(eco, burnin, timestep)\n@time simulate!(eco, times, timestep, record_interval, \"examples/Biodiversity\", \"Africa_run_coexist\");\n\nusing JLD\nusing Plots\nusing Diversity\nabuns = load(\"examples/Biodiversity/Africa_run_coexist100.jld\", \"abun\")\nmeta = Metacommunity(abuns)\ndiv = norm_sub_alpha(meta, 0)\nsumabuns = reshape(div[!, :diversity], 100, 100)\nheatmap(sumabuns,\n    background_color = :lightblue,\n    background_color_outside=:white,\n    grid = false, color = :algae,\n    aspect_ratio = 1, layout = (@layout [a b; c d]),\n    clim = (0, 50_000), margin = 0.5 * Plots.mm,\n    title = \"A\", titleloc = :left)\n\nabuns = load(\"examples/Biodiversity/Africa_run50.jld\", \"abun\")\nmeta = Metacommunity(abuns)\ndiv = norm_sub_alpha(meta, 0)\nsumabuns = reshape(div[!, :diversity], 100, 100)\nheatmap!(sumabuns,\n    background_color = :lightblue,\n    background_color_outside=:white,\n    grid = false, color = :algae,\n    aspect_ratio = 1, subplot = 2,\n    clim = (0, 50_000), right_margin = 2.0 * Plots.mm,\n    title = \"B\", titleloc = :left)\n\nabuns = load(\"examples/Biodiversity/Africa_run100.jld\", \"abun\")\nmeta = Metacommunity(abuns)\ndiv = norm_sub_alpha(meta, 0)\nsumabuns = reshape(div[!, :diversity], 100, 100)\nheatmap!(sumabuns,\n    background_color = :lightblue,\n    background_color_outside=:white,\n    grid = false, color = :algae,\n    aspect_ratio = 1, subplot = 3,\n    clim = (0, 50_000), right_margin = 2.0 * Plots.mm,\n    title = \"C\", titleloc = :left)\n\n\nabuns = load(\"examples/Biodiversity/Africa_run50.jld\", \"abun\")\nmeta = Metacommunity(abuns)\ndiv = norm_sub_rho(meta, 1.0)\nsumabuns = reshape(div[!, :diversity], 100, 100)\nheatmap!(sumabuns,\n    background_color = :lightblue,\n    background_color_outside=:white,\n    grid = false, color = :algae,\n    aspect_ratio = 1, subplot = 4,\n     right_margin = 2.0 * Plots.mm,\n    title = \"D\", titleloc = :left, clim = (0, 1))","category":"page"},{"location":"africa/","page":"Africa","title":"Africa","text":"(Image: ) Figure 2: 100 year simulations of Africa with 50,000 species. (A) Species richness after 100 years of simulation with all species equal. (B) Species richness after 50 years, with one specialist introduced. (C) Species richness after 100 years, with one specialist introduced. (D) Representativeness after 50 years with one specialist introduced (0 is completely unrepresentative of the ecosystem as a whole, 1 is completely representative).","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"","category":"page"},{"location":"api/","page":"API","title":"API","text":"Modules = [EcoSISTEM]\nPrivate = true","category":"page"},{"location":"api/#EcoSISTEM.AbstractAbiotic","page":"API","title":"EcoSISTEM.AbstractAbiotic","text":"AbstractAbiotic{H <: AbstractHabitat, B <: AbstractBudget} <: AbstractPartition\n\nAbstract supertype for all abiotic environment types and a subtype of AbstractPartition\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractBudget","page":"API","title":"EcoSISTEM.AbstractBudget","text":"AbstractBudget\n\nAbstract supertype for all budget types\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractEcosystem","page":"API","title":"EcoSISTEM.AbstractEcosystem","text":"AbstractEcosystem{Part <: AbstractAbiotic, SL <: SpeciesList,\n    TR <: AbstractTraitRelationship} <: AbstractMetacommunity{Float64,\n        Matrix{Int64}, Matrix{Float64}, SL, Part}\n\nAbstract supertype for all ecosystem types and a subtype of AbstractMetacommunity.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractHabitat","page":"API","title":"EcoSISTEM.AbstractHabitat","text":"AbstractHabitat\n\nAbstract supertype for all habitat types\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractMovement","page":"API","title":"EcoSISTEM.AbstractMovement","text":"AbstractMovement\n\nAbstract supertype of movements\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractParams","page":"API","title":"EcoSISTEM.AbstractParams","text":"AbstractParams\n\nAbstract supertype for all simulation parameter types\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractRequirement","page":"API","title":"EcoSISTEM.AbstractRequirement","text":"Abstract1Requirement{Energy}\n\nAbstract supertype for all species energy requirement types, parameterised by the type(s) of energy required Energy.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractScenario","page":"API","title":"EcoSISTEM.AbstractScenario","text":"AbstractScenario\n\nAbstract supertype for all whole ecosystem change scenarios\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractTraitRelationship","page":"API","title":"EcoSISTEM.AbstractTraitRelationship","text":"AbstractTraitRelationship{TR}\n\nThe abstract supertype of relationships between a trait and its environment, parameterised on any TR.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AbstractTraits","page":"API","title":"EcoSISTEM.AbstractTraits","text":"AbstractTraits{T}\n\nAbstract supertype for all trait types, parameterised by traits of any type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.AlwaysMovement","page":"API","title":"EcoSISTEM.AlwaysMovement","text":"AlwaysMovement{K <: AbstractKernel, B <: BoundaryCondition} <: AbstractMovement\n\nMovement can happen to any individual (\"animal-like\").\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.BirthOnlyMovement","page":"API","title":"EcoSISTEM.BirthOnlyMovement","text":"BirthOnlyMovement{K <: AbstractKernel, B <: BoundaryCondition} <: AbstractMovement\n\nMovement can only happen to individuals that have just been born (\"plant-like\").\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.BoundaryCondition","page":"API","title":"EcoSISTEM.BoundaryCondition","text":"BoundaryCondition\n\nAn abstract type for what should happen at the boundaries of an ecosystem.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Cache","page":"API","title":"EcoSISTEM.Cache","text":"Cache\n\nCache houses an integer array of moves made by all species in a timestep for the update! function, netmigration.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.CachedEcosystem","page":"API","title":"EcoSISTEM.CachedEcosystem","text":"CachedEcosystem{Part <: AbstractAbiotic, SL <: SpeciesList,\n    TR <: AbstractTraitRelationship} <: AbstractEcosystem{Part, SL, TR}\n\nCachedEcosystem houses the same information as Ecosystem (see ?Ecosystem), but holds the time period abundances as a CachedGridLandscape, so that they may be present or missing.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.CachedEcosystem-Tuple{Ecosystem, String, StepRangeLen}","page":"API","title":"EcoSISTEM.CachedEcosystem","text":"CachedEcosystem(eco::Ecosystem, outputfile::String, rng::StepRangeLen)\n\nFunction to create a CachedEcosystem given an existing ecosystem, eco, output folder to which the simulations are saved, outputfile, and a range of times over which to simulate, rng.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.CachedGridLandscape","page":"API","title":"EcoSISTEM.CachedGridLandscape","text":"CachedGridLandscape\n\nEcosystem abundances housed in the cached landscape. These are either stored in the matrix or output to a cache.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.ContinuousHab","page":"API","title":"EcoSISTEM.ContinuousHab","text":"ContinuousHab{C <: Number} <: AbstractHabitat{C}\n\nThis habitat subtype houses a habitat matrix matrix of any units, a grid square size size and HabitatUpdate type change.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.ContinuousTimeHab","page":"API","title":"EcoSISTEM.ContinuousTimeHab","text":"ContinuousTimeHab{C <: Number, M <: AbstractArray{C, 3}} <: AbstractHabitat{C}\n\nThis habitat subtype houses a habitat matrix matrix of any units, the time slice of the habitat matrix currently being operated on time, a grid square size size and HabitatUpdate type change.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.ContinuousTrait","page":"API","title":"EcoSISTEM.ContinuousTrait","text":"ContinuousTrait{C <: Number} <: AbstractTraits{T}\n\nAbstract trait type that holds information on a single continuous trait for each species, of any Number type C.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Cylinder","page":"API","title":"EcoSISTEM.Cylinder","text":"Cylinder <: BoundaryCondition\n\nA cylindrical boundary where species can cross the x boundary but not the y.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.DiscreteHab","page":"API","title":"EcoSISTEM.DiscreteHab","text":"DiscreteHab <: AbstractHabitat{String}\n\nThis habitat subtype has a matrix of strings and a float grid square size\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.DiscreteTrait","page":"API","title":"EcoSISTEM.DiscreteTrait","text":"BasicTrait{T} <: AbstractTraits{T}\n\nBasic trait type that holds information on a single trait for each species, of any type T.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Ecosystem","page":"API","title":"EcoSISTEM.Ecosystem","text":"Ecosystem{Part <: AbstractAbiotic} <:\n   AbstractEcosystem{Part, SL, TR}\n\nEcosystem houses information on species and their interaction with their environment. For species, it holds abundances and locations, abundances, as well as properties such as trait information, spplist, and movement types, lookup. For environments, it provides information on environmental conditions and available resources,abenv. Finally, there is a slot for the relationship between the environment and the characteristics of the species, relationship.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Ecosystem-Union{Tuple{Req}, Tuple{T}, Tuple{F}, Tuple{F, SpeciesList{T, Req, MO, T1, P} where {MO<:EcoSISTEM.AbstractMovement, T1<:Diversity.API.AbstractTypes, P<:EcoSISTEM.AbstractParams}, GridAbioticEnv, EcoSISTEM.AbstractTraitRelationship}} where {F<:Function, T, Req}","page":"API","title":"EcoSISTEM.Ecosystem","text":"Ecosystem(spplist::SpeciesList, abenv::GridAbioticEnv,\n    rel::AbstractTraitRelationship)\n\nFunction to create an Ecosystem given a species list, an abiotic environment and trait relationship. An optional population function can be added, popfun, which defaults to generic random filling of the ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.EqualPop","page":"API","title":"EcoSISTEM.EqualPop","text":"EqualPop <: AbstractParams\n\nParameter type that holds information on a population's birth and death rates, birth and death, specifically populations where all species have the same information. l represents the longevity of species based on their energy requirements and s is the survival of species dependent on how well their traits reflect the environment. Finally boost is used to manipulate how much of a boost the species get from being in an environment with lots of available energy.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.FluctScenario","page":"API","title":"EcoSISTEM.FluctScenario","text":"FluctScenario <: AbstractScenario\n\nThis scenario type holds a function that acts to fluctuate the environment.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Gauss","page":"API","title":"EcoSISTEM.Gauss","text":"Gauss{TR} <: AbstractTraitRelationship{TR}\n\nThe Gaussian relationship between a continuous trait and its environment, paramaterised on any TR.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.GaussTrait","page":"API","title":"EcoSISTEM.GaussTrait","text":"GaussTrait{C <: Number} <: ContinuousTrait{C}\n\nTrait type that holds Gaussian mean and variance trait information for each species, of any number type C.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.GaussianKernel","page":"API","title":"EcoSISTEM.GaussianKernel","text":"GaussianKernel <: AbstractKernel\n\nGaussianMovement holds parameters for a gaussian movement kernel; a dispersal variance for a species, var, and a threshold, thresh, beyond which dispersal cannot take place.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.GridAbioticEnv","page":"API","title":"EcoSISTEM.GridAbioticEnv","text":"GridAbioticEnv{H, B} <: AbstractAbiotic{H, B}\n\nThis abiotic environment type holds a habitat and budget, as well as a string of subcommunity names.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.GridLandscape","page":"API","title":"EcoSISTEM.GridLandscape","text":"GridLandscape\n\nEcosystem abundances housed in the landscape. These are represented in both 2 dimensions (for computational efficiency in simulations) and 3 dimensions (to represent species, their abundances and position in the grid).\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.LongTailKernel","page":"API","title":"EcoSISTEM.LongTailKernel","text":"LongTailKernel <: AbstractKernel\n\nLongTailKernel holds parameters for a movement kernel; a dispersal variance for a species, var, and a threshold, thresh, beyond which dispersal cannot take place.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Lookup","page":"API","title":"EcoSISTEM.Lookup","text":"Lookup\n\nLookup houses information on x, y grid locations and the probability of occurrence at the location for the species in question p. pnew and moves are initially empty storage and written over by the movement step in update!(). pnew is the recalculated probability based on which directions are available and moves is the number of moves to that grid location in that step.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Match","page":"API","title":"EcoSISTEM.Match","text":"Match{TR} <: AbstractTraitRelationship{TR}\n\nThe relationship between a discrete trait and its environment, paramaterised on any TR. Current conditions are matched to a trait preference and checked for a match.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.MultiScenario","page":"API","title":"EcoSISTEM.MultiScenario","text":"MultiScenario{S1 <: AbstractScenario, S2 <: AbstractScenario} <: AbstractScenario\n\nThis scenario type holds multiple different scenario types.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.NoBoundary","page":"API","title":"EcoSISTEM.NoBoundary","text":"NoBoundary <: BoundaryCondition\n\nA hard boundary where no species can cross.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.NoMovement","page":"API","title":"EcoSISTEM.NoMovement","text":"NoMovement{K <: AbstractKernel, B <: BoundaryCondition} <: AbstractMovement\n\nNo movement can take place.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.NoRelContinuous","page":"API","title":"EcoSISTEM.NoRelContinuous","text":"NoRelContinuous{TR} <: AbstractTraitRelationship{TR}\n\nThe absense of a relationship between a continuous trait and its environment, paramaterised on any TR. Returns the value 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.NoRelDiscrete","page":"API","title":"EcoSISTEM.NoRelDiscrete","text":"NoRelDiscrete{TR} <: AbstractTraitRelationship{TR}\n\nThe absense of a relationship between a discrete trait and its environment, paramaterised on any TR. Returns the value 1.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.PopGrowth","page":"API","title":"EcoSISTEM.PopGrowth","text":"PopGrowth <: AbstractParams\n\nBasic parameter type that holds information on a population's birth and death rates, birth and death, as well as how these are altered by energy availability. l represents the longevity of species based on their energy requirements and s is the survival of species dependent on how well their traits reflect the environment.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.RainBin","page":"API","title":"EcoSISTEM.RainBin","text":"RainBin{C <: Int} <: ContinuousTrait{C}\n\nTrait type that holds binned rainfall preference information created through ClimatePref. Holds an array of counts per rainfall band (mm).\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.SimpleBudget","page":"API","title":"EcoSISTEM.SimpleBudget","text":"SimpleBudget <: AbstractBudget{Float64}\n\nThis budget type has a matrix of floats, representing the energy budget of each subcommunity in the abiotic environment.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.SimpleRequirement","page":"API","title":"EcoSISTEM.SimpleRequirement","text":"SimpleRequirement <: Abstract1Requirement{Float64}\n\nA simple energy requirement is a single float for each species.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.SimpleScenario","page":"API","title":"EcoSISTEM.SimpleScenario","text":"SimpleScenario <: AbstractScenario\n\nThis scenario type holds a function that acts to change the entire ecosystem.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.SizeRequirement","page":"API","title":"EcoSISTEM.SizeRequirement","text":"SizeRequirement <: Abstract1Requirement{Float64}\n\nA simple energy requirement is a single float for each species.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.SolarBudget","page":"API","title":"EcoSISTEM.SolarBudget","text":"SolarBudget <: AbstractBudget{typeof(1.0*kJ)}\n\nThis budget type has a matrix of solar energy units, representing the energy budget of each subcommunity in the abiotic environment at a fixed point in time.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.SolarRequirement","page":"API","title":"EcoSISTEM.SolarRequirement","text":"SolarRequirement <: Abstract1Requirement{typeof(1.0*kJ)}\n\nA vector of solar energy requirements (kJ) for each species.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.SolarTimeBudget","page":"API","title":"EcoSISTEM.SolarTimeBudget","text":"SolarTimeBudget <: AbstractBudget{typeof(1.0*kJ)}\n\nThis budget type has a matrix of solar energy units, representing the energy budget of each subcommunity in the abiotic environment along with which time dimension we are interested in.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.SpeciesList","page":"API","title":"EcoSISTEM.SpeciesList","text":"SpeciesList{TR <: AbstractTraits, R <: AbstractRequirement,\n            MO <: AbstractMovement, T <: AbstractTypes,\n            P <: AbstractParams} <: AbstractTypes\n\nSpecies list houses all species-specific information including trait information, phylogenetic relationships, requirement for energy and movement types.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.SpeciesList-Union{Tuple{P}, Tuple{MO}, Tuple{R}, Tuple{Int64, Int64, Vector{Int64}, R, MO, P, Vector{Bool}, Vector{Float64}}} where {R<:EcoSISTEM.AbstractRequirement, MO<:EcoSISTEM.AbstractMovement, P<:EcoSISTEM.AbstractParams}","page":"API","title":"EcoSISTEM.SpeciesList","text":"SpeciesList{R <: AbstractRequirement,\n  MO <: AbstractMovement, P <: AbstractParams}(numspecies::Int64,\n  numtraits::Int64, abun_dist::Distribution, req::R,\n  movement::MO, params::P)\n\nFunction to create a SpeciesList given a number of species, the number of traits they possess, their abundances, requirement from the environment and their movement kernel.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.SpeciesList-Union{Tuple{P}, Tuple{T}, Tuple{MO}, Tuple{R}, Tuple{Int64, Int64, Vector{Int64}, R, MO, T, P, Vector{Bool}}} where {R<:EcoSISTEM.AbstractRequirement, MO<:EcoSISTEM.AbstractMovement, T<:Diversity.API.AbstractTypes, P<:EcoSISTEM.AbstractParams}","page":"API","title":"EcoSISTEM.SpeciesList","text":"SpeciesList{R <: AbstractRequirement, MO <: AbstractMovement,\n  T <: AbstractTypes, P <: AbstractParams}(numspecies::Int64,\n  numtraits::Int64, abun_dist::Distribution, req::R,\n  movement::MO, phy::T, params::P)\n\nFunction to create a SpeciesList given a number of species, the number of traits they possess, their abundances, requirement from the environment and their movement kernel and any type of AbstractTypes.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.TempBin","page":"API","title":"EcoSISTEM.TempBin","text":"TempBin{C <: Int} <: ContinuousTrait{C}\n\nTrait type that holds binned temperature preference information created through ClimatePref. Holds an array of counts per temperature band (°C).\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Torus","page":"API","title":"EcoSISTEM.Torus","text":"Torus <: BoundaryCondition\n\nA toroidal boundary where species can cross both boundaries.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.TraitCollection2","page":"API","title":"EcoSISTEM.TraitCollection2","text":"TraitCollection2{T1, T2} <: AbstractTraits{Tuple{T1, T2}}\n\nTrait collection that holds two trait types, TR1 and TR2.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.TraitCollection3","page":"API","title":"EcoSISTEM.TraitCollection3","text":"TraitCollection3{T1, T2, T3} <: AbstractTraits{Tuple{T1, T2, T3}}\n\nTrait collection that holds three trait types, TR1, TR2 and TR3.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Trapeze","page":"API","title":"EcoSISTEM.Trapeze","text":"Trapeze{TR} <: AbstractTraitRelationship{TR}\n\nThe relationship between a continuous trait and its environment, paramaterised on any TR.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Trapezoid","page":"API","title":"EcoSISTEM.Trapezoid","text":"Trapezoid{T<:Real} <: ContinuousUnivariateDistribution\n\nTrapezoidal distribution as described at https://en.wikipedia.org/wiki/Trapezoidal_distribution.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.Unif","page":"API","title":"EcoSISTEM.Unif","text":"Trapeze{TR} <: AbstractTraitRelationship{TR}\n\nThe relationship between a continuous trait and its environment, paramaterised on any TR.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.VolWaterBudget","page":"API","title":"EcoSISTEM.VolWaterBudget","text":"VolWaterBudget <: AbstractBudget{typeof(1.0*mm)}\n\nThis budget type has a matrix of water volumes, representing the energy budget of each subcommunity in the abiotic environment at a fixed point in time.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.VolWaterRequirement","page":"API","title":"EcoSISTEM.VolWaterRequirement","text":"VolWaterRequirement <: Abstract1Requirement{typeof(1.0*mm)}\n\nA vector of soil water volume requirements (m^3) for each species.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.VolWaterTimeBudget","page":"API","title":"EcoSISTEM.VolWaterTimeBudget","text":"VolWaterTimeBudget <: AbstractBudget{typeof(1.0*mm)}\n\nThis budget type has a matrix of volumetric soil water units, representing the water budget of each subcommunity in the abiotic environment along with which time dimension we are interested in.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.WaterBudget","page":"API","title":"EcoSISTEM.WaterBudget","text":"WaterBudget <: AbstractBudget{typeof(1.0*mm)}\n\nThis budget type has a matrix of rainfall energy units, representing the energy budget of each subcommunity in the abiotic environment at a fixed point in time.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.WaterRequirement","page":"API","title":"EcoSISTEM.WaterRequirement","text":"WaterRequirement <: Abstract1Requirement{typeof(1.0*mm)}\n\nA vector of water requirements (mm) for each species.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.WaterTimeBudget","page":"API","title":"EcoSISTEM.WaterTimeBudget","text":"WaterTimeBudget <: AbstractBudget{typeof(1.0*mm)}\n\nThis budget type has a matrix of rainfall units, representing the water budget of each subcommunity in the abiotic environment along with which time dimension we are interested in.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.additiveTR2","page":"API","title":"EcoSISTEM.additiveTR2","text":"additiveTR2{TR1, TR2} <: AbstractTraitRelationship{Tuple{TR1, TR2}}\n\nType that houses multiple AbstractTraitRelationships for two trait and habitat levels.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.additiveTR3","page":"API","title":"EcoSISTEM.additiveTR3","text":"multiplicativeTR3{TR1, TR2, TR3} <: AbstractTraitRelationship{Tuple{TR1, TR2, TR3}}\n\nType that houses multiple AbstractTraitRelationships for three trait and habitat levels.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.multiplicativeTR2","page":"API","title":"EcoSISTEM.multiplicativeTR2","text":"multiplicativeTR2{TR1, TR2} <: AbstractTraitRelationship{Tuple{TR1, TR2}}\n\nType that houses multiple AbstractTraitRelationships for two trait and habitat levels.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.multiplicativeTR3","page":"API","title":"EcoSISTEM.multiplicativeTR3","text":"multiplicativeTR3{TR1, TR2, TR3} <: AbstractTraitRelationship{Tuple{TR1, TR2, TR3}}\n\nType that houses multiple AbstractTraitRelationships for three trait and habitat levels.\n\n\n\n\n\n","category":"type"},{"location":"api/#EcoSISTEM.BM","page":"API","title":"EcoSISTEM.BM","text":"BM(T::Real, σ²::Float64, start::Float64, lab::String=\"\")\n\nFunction to evolve a Real value through Brownian motion, with a starting value,  start, and rate, σ².\n\n\n\n\n\n","category":"function"},{"location":"api/#EcoSISTEM.ContinuousEvolve-Tuple{Union{Float64, Unitful.Quantity{Float64, D, U} where {D, U}}, Union{Float64, Unitful.Quantity{Float64, D, U} where {D, U}}, Phylo.BinaryTree}","page":"API","title":"EcoSISTEM.ContinuousEvolve","text":"ContinuousEvolve(val::Union{Float64, Unitful.Quantity{Float64}}, var::Union{Float64, Unitful.Quantity{Float64}}, tree::BinaryTree)\n\nFunction to evolve a continuous trait along a BinaryTree, tree via Brownian motion. Takes in a starting value, val and a variance, var.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.DiscreteEvolve","page":"API","title":"EcoSISTEM.DiscreteEvolve","text":"DiscreteEvolve(numTraits::Int64, tree::BinaryTree)\n\nFunction to evolve a discrete switching trait along a BinaryTree, tree. Takes in a number of traits, numTraits to be switched between and rate to switch between traits, switch_rate with default value of 0.5.\n\n\n\n\n\n","category":"function"},{"location":"api/#EcoSISTEM.HabitatLoss-Tuple{EcoSISTEM.AbstractEcosystem, EcoSISTEM.AbstractHabitat, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.HabitatLoss","text":"HabitatLoss(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to destroy habitat for one timestep of the ecosystem using HabitatUpdate information.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.NoChange-Tuple{EcoSISTEM.AbstractEcosystem, EcoSISTEM.AbstractHabitat, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.NoChange","text":"NoChange(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to keep the habitat the same for one timestep of the model.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.RainfallChange-Tuple{EcoSISTEM.AbstractEcosystem, ContinuousHab, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.RainfallChange","text":"RainfallChange(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to change the rainfall for one timestep of the ecosystem using HabitatUpdate information.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.TempChange-Tuple{EcoSISTEM.AbstractEcosystem, ContinuousHab, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.TempChange","text":"TempChange(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to increase the temperature for one timestep of the ecosystem using HabitatUpdate information.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.TempFluct-Tuple{EcoSISTEM.AbstractEcosystem, ContinuousHab, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.TempFluct","text":"TempFluct(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to fluctuate the temperature for one timestep of the ecosystem using HabitatUpdate information.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.abundances-Tuple{CachedEcosystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.abundances","text":"abundances(cache::CachedEcosystem, tm::Unitful.Time)\n\nFunction to extract abundances for an ecosystem, cache, at a certain point in time, tm. If the abundances for that time are missing from the ecosystem, then the function checks on disk for the last saved version and simulates forward.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.assign_traits!-Tuple{Phylo.AbstractTree, DataFrames.DataFrame}","page":"API","title":"EcoSISTEM.assign_traits!","text":"assign_traits!(tree::AbstractTree, start::Vector{Float64},\n  σ²::Vector{Float64})\n\nFunction to evolve continuous functional traits through a phylogenetic tree through Brownian motion, with a starting value, start, and rate, σ².\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.assign_traits!-Tuple{Phylo.AbstractTree, Vector{Float64}, DataFrames.DataFrame}","page":"API","title":"EcoSISTEM.assign_traits!","text":"assign_traits!(tree::AbstractTree, switch_rate::Vector{Float64},\ntraits::Vector{Vector{String}})\n\nFunction to evolve categorical functional traits through a phylogenetic tree with a specific switching rate.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.budgetupdate!-Tuple{EcoSISTEM.AbstractEcosystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.budgetupdate!","text":"budgetupdate!(eco::AbstractEcosystem, timestep::Unitful.Time)\n\nFunction to update the budget of an ecosystem for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.calc_lookup_moves!-Tuple{NoBoundary, Int64, Int64, Int64, EcoSISTEM.AbstractEcosystem, Int64}","page":"API","title":"EcoSISTEM.calc_lookup_moves!","text":"calc_lookup_moves!(bound, x::Int64, y::Int64, sp::Int64, eco::Ecosystem, abun::Int64)\n\nFunction to calculate the number of moves taken by a species, sp, from a specific grid square location (x, y). There is a boundary condition, bound, which determines how the species can move across space (see AbstractBoundary). The total abundance of individuals is given in abun, which may be the number of births in the timestep, or total indiviuals.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.combineTR-Tuple{Union{multiplicativeTR2, multiplicativeTR3}}","page":"API","title":"EcoSISTEM.combineTR","text":"combineTR\n\nFunction that combines the output of multiple trait relationships, which varies depending on whether multiplicative, additive etc.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.convert_coords","page":"API","title":"EcoSISTEM.convert_coords","text":"convert_coords(eco, i::Int64, width::Int64)\nconvert_coords(eco, x::Int64, y::Int64, width::Int64)\n\nFunction to convert coordinates from two-dimensional (x,y) format to one dimension (i), or vice versa, using the width of the grid. This function can also be applied to arrays of coordinates.\n\n\n\n\n\n","category":"function"},{"location":"api/#EcoSISTEM.emptygridlandscape-Tuple{GridAbioticEnv, SpeciesList}","page":"API","title":"EcoSISTEM.emptygridlandscape","text":"emptygridlandscape(gae::GridAbioticEnv, spplist::SpeciesList)\n\nFunction to create an empty GridLandscape given a GridAbioticEnv and a SpeciesList.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.emptypopulate!-Union{Tuple{R}, Tuple{AB}, Tuple{GridLandscape, SpeciesList, AB, R}} where {AB<:EcoSISTEM.AbstractAbiotic, R<:EcoSISTEM.AbstractTraitRelationship}","page":"API","title":"EcoSISTEM.emptypopulate!","text":"emptypopulate!(ml::GridLandscape, spplist::SpeciesList,\n               abenv::AB, rel::R) where {AB <: EcoSISTEM.AbstractAbiotic, R <: EcoSISTEM.AbstractTraitRelationship}\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.energy_adjustment-Tuple{EcoSISTEM.AbstractEcosystem, EcoSISTEM.AbstractBudget, Int64, Int64}","page":"API","title":"EcoSISTEM.energy_adjustment","text":"energy_adjustment(eco::Ecosystem, bud::AbstractBudget, i::Int64, sp::Int64)\n\nFunction to calculate how much birth and death rates should be adjusted by, according to how much energy is available, bud, in the grid square, i, and how much energy the species, sp, requires.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.equalpop-Tuple{EqualPop, Any}","page":"API","title":"EcoSISTEM.equalpop","text":"equalpop(params::EqualPop, numspp)\n\nFunction that takes demographic parameters from type EqualPop and converts them into type PopGrowth based on the number of species (numspp).\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.eraAE-Tuple{EcoSISTEM.ClimatePref.ERA, Unitful.Quantity{Float64, D, U} where {D, U}, Union{Unitful.Quantity{Float64, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋^2, U}} where {L, S}} where U}","page":"API","title":"EcoSISTEM.eraAE","text":"eraAE(era::ERA, maxbud::Unitful.Quantity{Float64})\n\nFunction to create a ContinuousHab, SimpleBudget type abiotic environment from an ERA type climate. It either creates a SimpleBudget type filled with the maximum budget value maxbud or uses a provided budget of type SolarTimeBudget. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.eraChange-Tuple{EcoSISTEM.AbstractEcosystem, ContinuousTimeHab, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.eraChange","text":"eraChange(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to step the ERA climate forward by one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.genlookups-Tuple{EcoSISTEM.AbstractHabitat, GaussianKernel}","page":"API","title":"EcoSISTEM.genlookups","text":"genlookups(hab::AbstractHabitat, mov::GaussianMovement)\n\nFunction to generate lookup tables, which hold information on the probability of moving to neighbouring squares.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.geom_mean_abun-Tuple{Ecosystem, Vector{Float64}}","page":"API","title":"EcoSISTEM.geom_mean_abun","text":"geom_mean_abun(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate the geometric mean abundance for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.get_neighbours","page":"API","title":"EcoSISTEM.get_neighbours","text":"get_neighbours(mat::Matrix, x_coord::Int64, y_coord::Int64, chess::Int64=4)\n\nFunction to get the neighbours of a grid square in a matrix in 4 or 8 directions\n\n\n\n\n\n","category":"function"},{"location":"api/#EcoSISTEM.get_traits","page":"API","title":"EcoSISTEM.get_traits","text":"get_traits(tree::AbstractTree, tips::Bool=true)\n\nFunction to retrieve functional traits assigned to a phylogenetic tree, either just tips or all nodes.\n\n\n\n\n\n","category":"function"},{"location":"api/#EcoSISTEM.getbudget-Tuple{EcoSISTEM.AbstractEcosystem}","page":"API","title":"EcoSISTEM.getbudget","text":"getbudget(eco::Ecosystem)\n\nFunction to extract budget from Ecosystem object.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.getdimension-Tuple{EcoSISTEM.AbstractEcosystem}","page":"API","title":"EcoSISTEM.getdimension","text":"getdimension(eco::Ecosystem)\n\nFunction to extract dimension of habitat from Ecosystem object.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.getdispersaldist-Tuple{EcoSISTEM.AbstractEcosystem, Int64}","page":"API","title":"EcoSISTEM.getdispersaldist","text":"getdispersaldist(eco::Ecosystem)\n\nFunction to extract average dispersal distance of species from Ecosystem object. Returns a vector of distances, unless a specific species is provided as a String or Integer.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.getdispersalvar-Tuple{EcoSISTEM.AbstractEcosystem, Int64}","page":"API","title":"EcoSISTEM.getdispersalvar","text":"getdispersalvar(eco::Ecosystem)\n\nFunction to extract dispersal varaince of species from Ecosystem object. Returns a vector of distances, unless a specific species is provided as a String or Integer.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.getgridsize-Tuple{EcoSISTEM.AbstractEcosystem}","page":"API","title":"EcoSISTEM.getgridsize","text":"getgridsize(eco::Ecosystem)\n\nFunction to extract grid cell size of habitat from Ecosystem object.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.gethabitat-Tuple{EcoSISTEM.AbstractEcosystem}","page":"API","title":"EcoSISTEM.gethabitat","text":"gethabitat(eco::Ecosystem)\n\nFunction to extract habitat from Ecosystem object.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.getlookup-Tuple{EcoSISTEM.AbstractEcosystem, Int64}","page":"API","title":"EcoSISTEM.getlookup","text":"getlookup(eco::Ecosystem)\n\nFunction to extract movement lookup table of species from Ecosystem object.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.getpref-Union{Tuple{T}, Tuple{T, Symbol}} where T<:EcoSISTEM.AbstractTraits","page":"API","title":"EcoSISTEM.getpref","text":"getpref(traits::T, field::Symbol) where T <: AbstractTraits\n\nFunction to extract trait preferences for all species in the ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.getrelationship-Union{Tuple{R}, Tuple{R, Symbol}} where R<:EcoSISTEM.AbstractTraitRelationship","page":"API","title":"EcoSISTEM.getrelationship","text":"getpref(traits::T, field::Symbol) where T <: AbstractTraits\n\nFunction to extract the trait relationship of all species in the ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.getsize-Tuple{EcoSISTEM.AbstractEcosystem}","page":"API","title":"EcoSISTEM.getsize","text":"getsize(eco::Ecosystem)\n\nFunction to extract size of habitat from Ecosystem object.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.gettraitrel-Tuple{EcoSISTEM.AbstractEcosystem}","page":"API","title":"EcoSISTEM.gettraitrel","text":"gettraitrel(eco::Ecosystem)\n\nFunction to extract trait relationships.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.habitatupdate!-Tuple{EcoSISTEM.AbstractEcosystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.habitatupdate!","text":"habitatupdate!(eco::AbstractEcosystem, timestep::Unitful.Time)\n\nFunction to update the habitat of an ecosystem for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.makeunique-Tuple{Ecosystem}","page":"API","title":"EcoSISTEM.makeunique","text":"makeunique(eco::Ecosystem)\n\nFunction to convert type of similarity in SpeciesList to UniqueTypes, i.e. an identity matrix.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.mean_abun-Tuple{Ecosystem, Vector{Float64}}","page":"API","title":"EcoSISTEM.mean_abun","text":"mean_abun(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate the mean arithmetic abundance for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.meta_shannon-Tuple{Ecosystem, Vector{Float64}}","page":"API","title":"EcoSISTEM.meta_shannon","text":"meta_shannon(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate the Shannon entropy for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.meta_simpson-Tuple{Ecosystem, Vector{Float64}}","page":"API","title":"EcoSISTEM.meta_simpson","text":"meta_simpson(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate the Simpson diversity for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.meta_speciesrichness-Tuple{Ecosystem, Vector{Float64}}","page":"API","title":"EcoSISTEM.meta_speciesrichness","text":"meta_speciesrichness(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate the species richness for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.move!-Tuple{EcoSISTEM.AbstractEcosystem, AlwaysMovement, Int64, Int64, Matrix{Int64}, Int64}","page":"API","title":"EcoSISTEM.move!","text":"move!(eco::Ecosystem, ::AbstractMovement, i::Int64, sp::Int64, grd::Array{Int64, 2}, abun::Int64)\n\nFunction to calculate the movement of species sp from a given position in the landscape i, using the lookup table found in the Ecosystem and updating the movement patterns on a cached grid, grd. Optionally, a number of births can be provided, so that movement only takes place as part of the birth process, instead of the entire population\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.pd-Tuple{Ecosystem, Vector{Float64}}","page":"API","title":"EcoSISTEM.pd","text":"pd(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate Faith's phylogenetic diversity (PD) for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.peakedgradAE-Tuple{Union{Unitful.Quantity{Float64, 𝚯, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝚯, U}} where {L, S}} where U, Union{Unitful.Quantity{Float64, 𝚯, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝚯, U}} where {L, S}} where U, Tuple{Int64, Int64}, Unitful.Quantity{Float64, D, U} where {D, U}, Union{Unitful.Quantity{Float64, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋^2, U}} where {L, S}} where U, Unitful.Quantity{Float64, 𝚯 𝐓^-1, U} where U, Matrix{Bool}}","page":"API","title":"EcoSISTEM.peakedgradAE","text":"peakedgradAE(minT::Unitful.Temperature{Float64},\n   maxT::Unitful.Temperature{Float64},\n   dimension::Tuple{Int64, Int64}, maxbud::Unitful.Quantity{Float64},\n   area::Unitful.Area{Float64}, rate::Quantity{Float64, 𝚯*𝐓^-1},\n   active::Array{Bool, 2})\n\nFunction to create a temperature gradient ContinuousHab, SimpleBudget type abiotic environment. Given a min and max temperature, it generates a gradient from minima at the top and bottom peaking to maximum in the middle. It creates a ContinuousHab environment with dimensions dimension and a specified area area. It also creates a SimpleBudget type filled with the maximum budget value maxbud. The rate of temperature change is specified using the parameter rate. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.raingrad-Tuple{Union{Unitful.Quantity{Float64, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋, U}} where {L, S}} where U, Union{Unitful.Quantity{Float64, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋, U}} where {L, S}} where U, Union{Unitful.Quantity{Float64, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋, U}} where {L, S}} where U, Tuple{Int64, Int64}, Unitful.Quantity{Float64, 𝐋 𝐓^-1, U} where U}","page":"API","title":"EcoSISTEM.raingrad","text":"raingrad(minT::Unitful.Temperature{Float64}, maxT::Unitful.Temperature{Float64},\n  size::Unitful.Length{Float64},\n  dim::Tuple{Int64, Int64}, rate::Quantity{Float64, 𝚯*𝐓^-1})\n\nFunction to create a ContinuousHab habitat with a rainfall gradient.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.raingradAE-Tuple{Union{Unitful.Quantity{Float64, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋, U}} where {L, S}} where U, Union{Unitful.Quantity{Float64, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋, U}} where {L, S}} where U, Tuple{Int64, Int64}, Unitful.Quantity{Float64, D, U} where {D, U}, Union{Unitful.Quantity{Float64, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋^2, U}} where {L, S}} where U, Unitful.Quantity{Float64, 𝐋 𝐓^-1, U} where U, Matrix{Bool}}","page":"API","title":"EcoSISTEM.raingradAE","text":"raingradAE(min::Unitful.Temperature{Float64},\n  max::Unitful.Temperature{Float64},\n  dimension::Tuple{Int64, Int64}, maxbud::Float64,\n  area::Unitful.Area{Float64}, rate::Quantity{Float64, typeof(𝚯*𝐓^-1)},\n  active::Array{Bool, 2})\n\nFunction to create a rain gradient ContinuousHab, SimpleBudget type abiotic environment. Given a min and max rainfall, it generates a gradient from minimum at the bottom to maximum at the top. It creates a ContinuousHab environment with dimensions dimension and a specified area area. It also creates a SimpleBudget type filled with the maximum budget value maxbud. The rate of rainfall change is specified using the parameter rate. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.randomniches-Tuple{Tuple, Vector{Int64}, Float64, Vector{T} where T, Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.randomniches","text":"randomniches(dimension::Tuple, types::Vector{String}, clumpiness::Float64, weights::Vector)\n\nFunction to create a DiscreteHab habitat of dimension dimension, made up of sampled string types, types, that have a weighting, weights and clumpiness parameter, clumpiness.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.reenergise!-Tuple{Ecosystem, Union{Float64, Unitful.Quantity{Float64, D, U} where {D, U}}, Tuple{Int64, Int64}}","page":"API","title":"EcoSISTEM.reenergise!","text":"reenergise!(eco::Ecosystem, budget::Union{Float64, Unitful.Quantity{Float64}}, grid::Tuple{Int64, Int64})\n\nFunction to refill an ecosystem eco, with energy from a budget value, budget and a grid size.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.repopulate!-Tuple{Ecosystem}","page":"API","title":"EcoSISTEM.repopulate!","text":"repopulate!(eco::Ecosystem, abun::Int64)\n\nFunction to repopulate an ecosystem eco, with option for including trait preferences. An additional abun parameter can be included, in order to repopulate the ecosystem with a specified number of individuals.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.resetrate!-Tuple{EcoSISTEM.AbstractEcosystem, Unitful.Quantity{Float64, Unitful.Dimensions{(Unitful.Dimension{:Time}(-1//1),)}, U} where U}","page":"API","title":"EcoSISTEM.resetrate!","text":"resetrate!(eco::Ecosystem, rate::Quantity{Float64, typeof(𝐓^-1)})\n\nFunction to reset the rate of habitat change for a species.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.runscenario!-Tuple{Ecosystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, SimpleScenario, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.runscenario!","text":"runscenario!(eco::Ecosystem, timestep::Unitful.Time, scenario::S, currentstep::Unitful.Time) where S <: AbstractScenario\n\nThis function runs any scenario type for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.simplehabitat-Tuple{Unitful.Quantity, Union{Unitful.Quantity{T, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐋, U}} where {L, S}} where {T, U}, Tuple{Int64, Int64}}","page":"API","title":"EcoSISTEM.simplehabitat","text":"simplehabitat(val::Unitful.Quantity, size::Unitful.Length,\ndim::Tuple{Int64, Int64})\n\nFunction to create a ContinuousHab habitat of dimension dim, with cell size and filled value, val.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.simplehabitatAE-Tuple{Union{Float64, Unitful.Quantity{Float64, D, U} where {D, U}}, Tuple{Int64, Int64}, Unitful.Quantity{Float64, D, U} where {D, U}, Union{Unitful.Quantity{Float64, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋^2, U}} where {L, S}} where U, Matrix{Bool}}","page":"API","title":"EcoSISTEM.simplehabitatAE","text":"simplehabitatAE(val::Union{Float64, Unitful.Quantity{Float64}},\n    dimension::Tuple{Int64, Int64}, maxbud::Float64, area::Unitful.Area{Float64},\n    active::Array{Bool, 2})\n\nFunction to create a simple ContinuousHab, SimpleBudget type abiotic environment. It creates a ContinuousHab filled with a given value, val, dimensions (dimension) and a specified area (area). It also creates a SimpleBudget type filled with the maximum budget value (maxbud). The rate of temperature change is specified using the parameter rate. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.simplenicheAE-Tuple{Int64, Tuple, Unitful.Quantity{Float64, D, U} where {D, U}, Union{Unitful.Quantity{Float64, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋^2, U}} where {L, S}} where U, Matrix{Bool}}","page":"API","title":"EcoSISTEM.simplenicheAE","text":"simplenicheAE(numniches::Int64, dimension::Tuple,\n                    maxBud::Float64, area::Unitful.Area{Float64},\n                    active::Array{Bool, 2})\n\nFunction to create a simple DiscreteHab, SimpleBudget type abiotic environment. Given a number of niche types numniches, it creates a DiscreteHab environment with dimensions dimension and a specified area area. It also creates a SimpleBudget type filled with the maximum budget value maxbud. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.simulate!-Tuple{EcoSISTEM.AbstractEcosystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.simulate!","text":"simulate!(eco::Ecosystem, duration::Unitful.Time, interval::Unitful.Time,\n     timestep::Unitful.Time)\n\nFunction to run an ecosystem, eco for specified length of times, duration, for a particular timestep, 'timestep'.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.simulate_record!-Tuple{AbstractArray, Ecosystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.simulate_record!","text":"simulate_record!(eco::Ecosystem, duration::Unitful.Time, interval::Unitful.Time,\n     timestep::Unitful.Time)\n\nFunction to run an ecosystem, eco for specified length of times, duration, for a particular timestep, 'timestep', and time interval for abundances to be recorded, interval. Optionally, there may also be a scenario by which the whole ecosystem is updated, such as removal of habitat patches.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.simulate_record_diversity!-Union{Tuple{F}, Tuple{AbstractArray, Ecosystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}, SimpleScenario, F, Vector{Float64}}} where F<:Function","page":"API","title":"EcoSISTEM.simulate_record_diversity!","text":"simulate_record_diversity!(storage::AbstractArray, eco::Ecosystem,\n  times::Unitful.Time, interval::Unitful.Time,timestep::Unitful.Time,\n  scenario::SimpleScenario, divfun::Function, qs::Float64)\n\nFunction to run an ecosystem, eco for specified length of times, duration, for a particular timestep, 'timestep', and time interval for a diversity to be calculated and recorded, interval. Optionally, there may also be a scenario by which the whole ecosystem is updated, such as removal of habitat patches.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.sorenson-Tuple{Ecosystem, Vector{Float64}}","page":"API","title":"EcoSISTEM.sorenson","text":"sorenson(eco::Ecosystem, qs::Vector{Float64})\n\nFunction to calculate the Sorenson similarity for the entire ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.tematch-Tuple{SpeciesList, EcoSISTEM.AbstractAbiotic}","page":"API","title":"EcoSISTEM.tematch","text":"tematch(sppl::SpeciesList, abenv::AbstractAbiotic)\n\nFunction to check that the types of a trait list and habitat list are the same for a species list (sppl) and abiotic environment (abenv).\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.tempgrad-Tuple{Union{Unitful.Quantity{Float64, 𝚯, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝚯, U}} where {L, S}} where U, Union{Unitful.Quantity{Float64, 𝚯, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝚯, U}} where {L, S}} where U, Union{Unitful.Quantity{Float64, 𝐋, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋, U}} where {L, S}} where U, Tuple{Int64, Int64}, Unitful.Quantity{Float64, 𝚯 𝐓^-1, U} where U}","page":"API","title":"EcoSISTEM.tempgrad","text":"tempgrad(minT::Unitful.Temperature{Float64}, maxT::Unitful.Temperature{Float64},\n  size::Unitful.Length{Float64},\n  dim::Tuple{Int64, Int64}, rate::Quantity{Float64, 𝚯*𝐓^-1})\n\nFunction to create a ContinuousHab habitat with a temperature gradient.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.tempgradAE-Tuple{Union{Unitful.Quantity{Float64, 𝚯, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝚯, U}} where {L, S}} where U, Union{Unitful.Quantity{Float64, 𝚯, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝚯, U}} where {L, S}} where U, Tuple{Int64, Int64}, Unitful.Quantity{Float64, D, U} where {D, U}, Union{Unitful.Quantity{Float64, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋^2, U}} where {L, S}} where U, Unitful.Quantity{Float64, 𝚯 𝐓^-1, U} where U, Matrix{Bool}}","page":"API","title":"EcoSISTEM.tempgradAE","text":"tempgradAE(min::Unitful.Temperature{Float64},\n  max::Unitful.Temperature{Float64},\n  dimension::Tuple{Int64, Int64}, maxbud::Float64,\n  area::Unitful.Area{Float64}, rate::Quantity{Float64, typeof(𝚯*𝐓^-1)},\n  active::Array{Bool, 2})\n\nFunction to create a temperature gradient ContinuousHab, SimpleBudget type abiotic environment. Given a min and max temperature, it generates a gradient from minimum at the bottom to maximum at the top. It creates a ContinuousHab environment with dimensions dimension and a specified area area. It also creates a SimpleBudget type filled with the maximum budget value maxbud. The rate of temperature change is specified using the parameter rate. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.traitfun-Tuple{EcoSISTEM.AbstractEcosystem, Int64, Int64}","page":"API","title":"EcoSISTEM.traitfun","text":"traitfun(eco::AbstractEcosystem, pos::Int64, sp::Int64)\n\nFunction to calculate relationship between the current environment and a species' particular trait.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.traitpopulate!-Union{Tuple{R}, Tuple{AB}, Tuple{GridLandscape, SpeciesList, AB, R}} where {AB<:EcoSISTEM.AbstractAbiotic, R<:EcoSISTEM.AbstractTraitRelationship}","page":"API","title":"EcoSISTEM.traitpopulate!","text":"traitpopulate!(ml::GridLandscape, spplist::SpeciesList,\n               abenv::AbstractAbiotic)\n\nFunction to populate a grid landscape given the abundances found in species list based upon how well the species traits match their environment.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.traitrepopulate!-Tuple{Ecosystem}","page":"API","title":"EcoSISTEM.traitrepopulate!","text":"repopulate!(eco::Ecosystem, abun::Int64)\n\nFunction to repopulate an ecosystem eco, with option for including trait preferences. An additional abun parameter can be included, in order to repopulate the ecosystem with a specified number of individuals.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.trmatch-Tuple{SpeciesList, EcoSISTEM.AbstractTraitRelationship}","page":"API","title":"EcoSISTEM.trmatch","text":"trmatch(sppl::SpeciesList, traitrel::AbstractTraitRelationship)\n\nFunction to check that the types of a trait list and trait relationship list are the same for a species list (sppl) and trait relationship (traitrel).\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.update!-Tuple{Ecosystem, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.update!","text":"update!(eco::Ecosystem, time::Unitful.Time)\n\nFunction to update a ecosystem abundances and environment for one timestep.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.update_energy_usage!-Union{Tuple{EcoSISTEM.AbstractEcosystem{A, SpeciesList{Tr, Req, B, C, D}, E}}, Tuple{Req}, Tuple{Tr}, Tuple{E}, Tuple{D}, Tuple{C}, Tuple{B}, Tuple{A}} where {A, B, C, D, E, Tr, Req<:EcoSISTEM.Abstract1Requirement}","page":"API","title":"EcoSISTEM.update_energy_usage!","text":"update_energy_usage!(eco::Ecosystem)\n\nFunction to calculate how much energy has been used up by the current species in each grid square in the ecosystem, eco. This function is parameterised on whether the species have one type of energy requirement or two.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.worldclimAE-Tuple{EcoSISTEM.ClimatePref.Worldclim, Unitful.Quantity{Float64, D, U} where {D, U}, Union{Unitful.Quantity{Float64, 𝐋^2, U}, Unitful.Level{L, S, Unitful.Quantity{Float64, 𝐋^2, U}} where {L, S}} where U}","page":"API","title":"EcoSISTEM.worldclimAE","text":"worldclimAE(wc::Worldclim, maxbud::Unitful.Quantity{Float64})\n\nFunction to create a ContinuousHab, SimpleBudget type abiotic environment from an Wordclim type climate. It either creates a SimpleBudget type filled with the maximum budget value maxbud or uses a provided budget of type SolarTimeBudget. If a Bool matrix of active grid squares is included, active, this is used, else one is created with all grid cells active.\n\n\n\n\n\n","category":"method"},{"location":"api/#EcoSISTEM.worldclimChange-Tuple{EcoSISTEM.AbstractEcosystem, ContinuousTimeHab, Union{Unitful.Quantity{T, 𝐓, U}, Unitful.Level{L, S, Unitful.Quantity{T, 𝐓, U}} where {L, S}} where {T, U}}","page":"API","title":"EcoSISTEM.worldclimChange","text":"worldclimChange(eco::AbstractEcosystem, hab::ContinuousHab, timestep::Unitful.Time)\n\nFunction to step the Worldclim climate forward by one timestep.\n\n\n\n\n\n","category":"method"},{"location":"diversity/#Integration-with-Diversity.jl","page":"Diversity","title":"Integration with Diversity.jl","text":"","category":"section"},{"location":"diversity/","page":"Diversity","title":"Diversity","text":"EcoSISTEM is integrated with the Diversity package, so that diversity measures can be calculated directly on ecosystems.","category":"page"},{"location":"diversity/","page":"Diversity","title":"Diversity","text":"See Basics for more information on setting up an Ecosystem.","category":"page"},{"location":"diversity/","page":"Diversity","title":"Diversity","text":"using Diversity\n# Subcommunity measures\nnorm_sub_alpha(eco, 1.0)\n# Or metacommunity measures\nnorm_meta_alpha(eco, 1.0)\n# Or multiple values of q\nnorm_sub_beta(eco, 0.0:3.0)","category":"page"},{"location":"examples/#Examples","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we describe several properties that the model ecosystem should be able to recreate, namely:","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"Species are more abundant when more resources are available to them.\nSpecies' abundances scale with area and are invariant to grid size.\nSpecies with larger average dispersal distances can move further and faster across the landscape.\nSpecies have a competitive advantage when their niche preference is close to that of the climate.\nSpecialist species with a narrow niche width have a competitive advantage over generalists with a broad niche width, for the same niche preference.\nLarge numbers of species are sustained over large areas.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"What follows are several examples of this operating in practice.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"using EcoSISTEM\nusing EcoSISTEM.Units\nusing Unitful\nusing Unitful.DefaultSymbols\nusing Diversity\nusing JLD\nusing OnlineStats\nusing Plots\nusing Distributions\nusing Diversity\nplotlyjs()","category":"page"},{"location":"examples/#.-Different-niche-preferences-and-widths","page":"Examples","title":"1. Different niche preferences and widths","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Here we compare the abundances of species with different temperature preferences and tolerances. On a small patch,we explored the abundance of species given different niche preferences, with all other parameters kept equal. We found that species with niche preference nearer to the 25°C optimum were more abundant, when all species were given the same niche widths. Additionally, when all species had a preference for the 25°C climate and a range of niche widths, those with broader niche widths (generalists) were less abundant than species with narrow (specialists). If the temperature in the ecosystem was then increased by 1°C, those with the narrowest niches went extinct, and the generalists became more abundant, with a preference for those with a niche width of around 1°C as we would expect.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"numSpecies = 100; grd = (10,10); req=(450000.0kJ/m^2, 192.0nm/m^2);\nindividuals = 100_000_000; area = 100.0*km^2;\ntotalK = (4.5e11kJ/km^2, 192.0mm/km^2)\n\nabenv1 = simplehabitatAE(298.0K, grd, totalK[1], area)\nabenv2 = simplehabitatAE(298.0K, grd, totalK[2], area)\nbud = BudgetCollection2(abenv1.budget, abenv2.budget)\nabenv = GridAbioticEnv{typeof(abenv1.habitat), typeof(bud)}(abenv1.habitat, abenv1.active, bud, abenv1.names)\n\nvars = fill(2.0, numSpecies) .* K\nopts = 298.0K .+ vars .* range(-3, stop = 3, length = numSpecies)\n\nav_dist = fill(2.4, numSpecies) .* km\nkernel = GaussianKernel.(av_dist, 10e-10)\n\ndeath = 0.15/ year\nbirth = death\nl = 1.0\ns = 0.1\nboost = 1.0\n\nsize_mean = 1.0m^2\n# Set up how much energy each species consumes\nenergy_vec1 = SolarRequirement(fill(req[1] * size_mean, numSpecies))\nenergy_vec2 = WaterRequirement(fill(req[2] * size_mean, numSpecies))\n\nenergy_vec = ReqCollection2(energy_vec1, energy_vec2)\nparam = EqualPop(birth, death, l, s , boost)\n\n# Create ecosystem\n\nmovement = BirthOnlyMovement(kernel, Torus())\n\ntraits = GaussTrait(opts, vars)\nnative = fill(true, numSpecies)\nabun = rand(Multinomial(individuals, numSpecies))\nsppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n    movement, param, native)\nrel = Gauss{typeof(first(opts))}()\neco = Ecosystem(sppl, abenv, rel)\n\ntimes = 10years; timestep = 1month\nlensim = length(0month:timestep:times)\n\nsimulate!(eco, times, timestep)\nendabun = eco.abundances.matrix\ntemps = map(eachindex(opts)) do i\n    repeat([opts[i]], endabun[i])\nend\n\ntemps = vcat(temps...)\nedges = collect(292.0:1:304) .* K\nh = Hist(edges)\nfit!(h, temps)\nbar(ustrip.(uconvert.(°C, edges)), h.counts,\ngrid = false, xlab = \"Temperature preference (°C)\",\nylab = \"Abundance\",\nguidefontsize = 16, tickfontsize= 16, size = (1200, 1000),\ntitlefontsize = 16, title = \"A\", titleloc = :left,\nmargin = 10.0*Plots.mm, label = \"\", layout = (@layout[a; b c]))\n\n## DIFFERENT VARS ##\n\nnumSpecies = 100; grd = (10,10); req=(450000.0kJ/m^2, 192.0nm/m^2);\nindividuals = 100_000_000; area = 100.0*km^2;\ntotalK = (4.5e11kJ/km^2, 192.0mm/km^2)\n\nabenv1 = simplehabitatAE(298.0K, grd, totalK[1], area)\nabenv2 = simplehabitatAE(298.0K, grd, totalK[2], area)\nbud = BudgetCollection2(abenv1.budget, abenv2.budget)\nabenv = GridAbioticEnv{typeof(abenv1.habitat), typeof(bud)}(abenv1.habitat, abenv1.active, bud, abenv1.names)\n\nvars = range(0.0001, stop = 5, length = numSpecies) .* K\nopts = fill(298.0K, numSpecies)\n\nav_dist = fill(2.4, numSpecies) .* km\nkernel = GaussianKernel.(av_dist, 10e-10)\n\ndeath = 0.15/ year\nbirth = death\nl = 1.0\ns = 0.1\nboost = 1.0\n\nsize_mean = 1.0m^2\n# Set up how much energy each species consumes\nenergy_vec1 = SolarRequirement(fill(req[1] * size_mean, numSpecies))\nenergy_vec2 = WaterRequirement(fill(req[2] * size_mean, numSpecies))\n\nenergy_vec = ReqCollection2(energy_vec1, energy_vec2)\nparam = EqualPop(birth, death, l, s , boost)\n\n# Create ecosystem\n\nmovement = BirthOnlyMovement(kernel, Torus())\n\ntraits = GaussTrait(opts, vars)\nnative = fill(true, numSpecies)\nabun = rand(Multinomial(individuals, numSpecies))\nsppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n    movement, param, native)\nrel = Gauss{typeof(first(opts))}()\neco = Ecosystem(sppl, abenv, rel)\n\ntimes = 10years; timestep = 1month\nlensim = length(0month:timestep:times)\n\nsimulate!(eco, times, timestep)\nendabun = eco.abundances.matrix\nwidths = map(eachindex(vars)) do i\n    repeat([vars[i]], endabun[i])\nend\nwidths = vcat(widths...)\nedges = collect(0.1:0.2:5) .* K\nh = Hist(edges)\nfit!(h, widths)\nbar!(edges./K, h.counts, grid = false,\nxlab = \"Niche width (°C)\", ylab = \"Abundance\",\nguidefontsize = 16, tickfontsize= 16, titlefontsize = 16,\nmargin = 10.0*Plots.mm, left_margin = 20.0 * Plots.mm, label = \"\",\nsubplot = 2,\ntitle = \"B\", titleloc = :left, ylim = (0, 32_000))\n\n## DIFFERENT VARS MISMATCH ##\nnumSpecies = 100; grd = (10,10); req=(450000.0kJ/m^2, 192.0nm/m^2);\nindividuals = 100_000_000; area = 100.0*km^2;\ntotalK = (4.5e11kJ/km^2, 192.0mm/km^2)\n\nabenv1 = simplehabitatAE(299.0K, grd, totalK[1], area)\nabenv2 = simplehabitatAE(299.0K, grd, totalK[2], area)\nbud = BudgetCollection2(abenv1.budget, abenv2.budget)\nabenv = GridAbioticEnv{typeof(abenv1.habitat), typeof(bud)}(abenv1.habitat, abenv1.active, bud, abenv1.names)\n\nvars = range(0.0001, stop = 5, length = numSpecies) .* K\nopts = fill(298.0K, numSpecies)\n\nav_dist = fill(2.4, numSpecies) .* km\nkernel = GaussianKernel.(av_dist, 10e-10)\n\ndeath = 0.15/ year\nbirth = death\nl = 1.0\ns = 0.1\nboost = 1.0\n\nsize_mean = 1.0m^2\n# Set up how much energy each species consumes\nenergy_vec1 = SolarRequirement(fill(req[1] * size_mean, numSpecies))\nenergy_vec2 = WaterRequirement(fill(req[2] * size_mean, numSpecies))\n\nenergy_vec = ReqCollection2(energy_vec1, energy_vec2)\nparam = EqualPop(birth, death, l, s , boost)\n\n# Create ecosystem\n\nmovement = BirthOnlyMovement(kernel, Torus())\n\ntraits = GaussTrait(opts, vars)\nnative = fill(true, numSpecies)\nabun = rand(Multinomial(individuals, numSpecies))\nsppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n    movement, param, native)\nrel = Gauss{typeof(first(opts))}()\neco = Ecosystem(sppl, abenv, rel)\n\ntimes = 10years; timestep = 1month\nlensim = length(0month:timestep:times)\n\nsimulate!(eco, times, timestep)\nendabun = eco.abundances.matrix\nwidths = map(eachindex(vars)) do i\n    repeat([vars[i]], endabun[i])\nend\nwidths = vcat(widths...)\nedges = collect(0.1:0.2:5) .* K\nh = Hist(edges)\nfit!(h, widths)\nbar!(edges./K, h.counts, grid = false,\nxlab = \"Niche width (°C)\", ylab = \"\",\nguidefontsize = 16, tickfontsize= 16, titlefontsize = 16,\nmargin = 10.0*Plots.mm, label = \"\", subplot = 3,\ntitle = \"C\", titleloc = :left, ylim = (0, 32_000))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) Abundance of species across 100km² patch ecosystem with 100 species, (A) with a different temperature preferences and a homogeneous climate of 25°C, (B)  with different niche widths and a temperature preference for 25°C and (C) different niche widths with a shifted homogeneous climate of 26°C.","category":"page"},{"location":"examples/#.-Varying-resources,-grid-sizes,-areas-and-number-of-species","page":"Examples","title":"2. Varying resources, grid sizes, areas and number of species","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Firstly, we confirmed that abundance depended upon the amount of available resource. Here, we simulated an island ecosystem with two resources, water and sunlight, each on a gradient West to East and South to North, respectively. All species were seeded with the same resource requirements and vital rates. Abundance increased in squares with greater amounts of water and sunlight, with some edge effects. Next, we investigated the relationship between abundance and area size. As expected, ecosystems with greater areas could support more individuals, and these abundances were invariant to the resolution of the grid. We also tested in an ecosystem in which species demographic and dispersal rates and resource requirements varied. Under these circumstances, some species not favoured for the conditions go extinct, but most species survive to the end of the simulation.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"## MORE ENERGY MORE ABUNDANCE ##\nnumSpecies = 100; grd = (10,10); req=(450000.0kJ/m^2, 192.0nm/m^2); individuals = 100_000_000; area = 100.0*km^2; totalK = (4.5e11kJ/km^2, 192.0mm/km^2)\n\nabenv1 = simplehabitatAE(298.0K, grd, totalK[1], area)\nabenv2 = simplehabitatAE(298.0K, grd, totalK[2], area)\nbud = BudgetCollection2(abenv1.budget, abenv2.budget)\nabenv = GridAbioticEnv{typeof(abenv1.habitat), typeof(bud)}(abenv1.habitat, abenv1.active, bud, abenv1.names)\ngsize = size(abenv.budget.b1.matrix, 1)\nsol_range = collect(range(0.0kJ, stop = 4.5e11kJ, length = gsize))\n map(1:gsize) do seq\n   abenv.budget.b1.matrix[seq, :] .= sol_range[seq]\n end\nabenv.budget.b1.matrix\n\ngsize = size(abenv.budget.b2.matrix, 1)\nwater_range = collect(range(0.0mm, stop = 192mm, length = gsize))\nmap(1:gsize) do seq\n    abenv.budget.b2.matrix[:, seq] .= water_range[seq]\nend\nabenv.budget.b2.matrix\n\nvars = fill(2.0, numSpecies) .* K\nopts = fill(298.0, numSpecies) .* K\nav_dist = fill(2.4, numSpecies) .* km\nkernel = GaussianKernel.(av_dist, 10e-10)\n\ndeath = 0.15/ year\nbirth = death\nl = 1.0\ns = 0.1\nboost = 1.0\n\nsize_mean = 1.0m^2\n# Set up how much energy each species consumes\nenergy_vec1 = SolarRequirement(fill(req[1] * size_mean, numSpecies))\nenergy_vec2 = WaterRequirement(fill(req[2] * size_mean, numSpecies))\n\nenergy_vec = ReqCollection2(energy_vec1, energy_vec2)\nparam = EqualPop(birth, death, l, s , boost)\n\n# Create ecosystem\n\nmovement = BirthOnlyMovement(kernel, NoBoundary())\n\ntraits = GaussTrait(opts, vars)\nnative = fill(true, numSpecies)\nabun = rand(Multinomial(individuals, numSpecies))\nsppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n    movement, param, native)\nrel = Gauss{typeof(first(opts))}()\neco = Ecosystem(sppl, abenv, rel)\n\ntimes = 10years; timestep = 1month\nlensim = length(0month:timestep:times)\n\nsimulate!(eco, times, timestep)\nendabun = sum(eco.abundances.matrix, dims = 1)\nendabun = reshape(endabun, 10, 10)\n\nheatmap(sol_range./kJ, water_range./mm, endabun, grid = false,\n xlab = \"Solar energy\", ylab = \"Water\", size = (1600, 1200),\nguidefontsize = 16, tickfontsize= 16, titlefontsize=24,\nmargin = 10.0*Plots.mm, legendfontsize = 16, label = \"\", left_margin = 20.0 * Plots.mm,\nlayout = (@layout [a b; c d]), title = \"A\", titleloc = :left)\n\n\n\n## INVARIANT TO GRID SIZE ##\ntimes = 10years; timestep = 1month\nlensim = length(0month:timestep:times)\nendabuns = zeros(Int64, 4)\ngrids = [1,2,5,10]\nfor i in eachindex(grids)\n    numSpecies = 100; grd = (grids[i],grids[i]); req=(450000.0kJ/m^2, 192.0nm/m^2);\n    individuals = 100_000_000; area = 100.0*km^2;\n    totalK = (4.5e11kJ/km^2, 192.0mm/km^2)\n\n    abenv1 = simplehabitatAE(298.0K, grd, totalK[1], area)\n    abenv2 = simplehabitatAE(298.0K, grd, totalK[2], area)\n    bud = BudgetCollection2(abenv1.budget, abenv2.budget)\n    abenv = GridAbioticEnv{typeof(abenv1.habitat), typeof(bud)}(abenv1.habitat, abenv1.active, bud, abenv1.names)\n\n    vars = fill(2.0, numSpecies) .* K\n    opts = fill(298.0, numSpecies) .* K\n    av_dist = fill(2.4, numSpecies) .* km\n    kernel = GaussianKernel.(av_dist, 10e-10)\n\n    death = 0.15/ year\n    birth = death\n    l = 1.0\n    s = 0.1\n    boost = 1.0\n\n    size_mean = 1.0m^2\n    # Set up how much energy each species consumes\n    energy_vec1 = SolarRequirement(fill(req[1] * size_mean, numSpecies))\n    energy_vec2 = WaterRequirement(fill(req[2] * size_mean, numSpecies))\n\n    energy_vec = ReqCollection2(energy_vec1, energy_vec2)\n    param = EqualPop(birth, death, l, s , boost)\n\n    # Create ecosystem\n\n    movement = BirthOnlyMovement(kernel, NoBoundary())\n\n    traits = GaussTrait(opts, vars)\n    native = fill(true, numSpecies)\n    abun = rand(Multinomial(individuals, numSpecies))\n    sppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n        movement, param, native)\n    rel = Gauss{typeof(first(opts))}()\n    eco = Ecosystem(sppl, abenv, rel)\n    simulate!(eco, times, timestep)\n    endabuns[i] = sum(eco.abundances.matrix)\nend\n\nbar!(string.(grids), endabuns,\ngrid = false, xlab = \"Number of grid squares\",\nylab = \"Total abundance\",\nguidefontsize = 16,tickfontsize= 16, titlefontsize=24,\nmargin = 10.0*Plots.mm, label = \"\", left_margin = 20.0 * Plots.mm,\nsubplot = 2, title = \"B\", titleloc = :left)\n\n## ABUNDANCE SCALES WITH AREA ##\ntimes = 10years; timestep = 1month\nlensim = length(0month:timestep:times)\nendabuns = zeros(Int64, 4)\nareas = [10.0,20.0,50.0,100.0]\nfor i in eachindex(areas)\n    numSpecies = 100; grd = (10,10); req=(450000.0kJ/m^2, 192.0nm/m^2);\n    individuals = 100_000_000; area = areas[i].*km^2;\n    totalK = (4.5e11kJ/km^2, 192.0mm/km^2)\n\n    abenv1 = simplehabitatAE(298.0K, grd, totalK[1], area)\n    abenv2 = simplehabitatAE(298.0K, grd, totalK[2], area)\n    bud = BudgetCollection2(abenv1.budget, abenv2.budget)\n    abenv = GridAbioticEnv{typeof(abenv1.habitat), typeof(bud)}(abenv1.habitat, abenv1.active, bud, abenv1.names)\n\n    vars = fill(2.0, numSpecies) .* K\n    opts = fill(298.0, numSpecies) .* K\n    av_dist = fill(2.4, numSpecies) .* km\n    kernel = GaussianKernel.(av_dist, 10e-10)\n\n    death = 0.15/ year\n    birth = death\n    l = 1.0\n    s = 0.1\n    boost = 1.0\n\n    size_mean = 1.0m^2\n    # Set up how much energy each species consumes\n    energy_vec1 = SolarRequirement(fill(req[1] * size_mean, numSpecies))\n    energy_vec2 = WaterRequirement(fill(req[2] * size_mean, numSpecies))\n\n    energy_vec = ReqCollection2(energy_vec1, energy_vec2)\n    param = EqualPop(birth, death, l, s , boost)\n\n    # Create ecosystem\n\n    movement = BirthOnlyMovement(kernel, NoBoundary())\n\n    traits = GaussTrait(opts, vars)\n    native = fill(true, numSpecies)\n    abun = rand(Multinomial(individuals, numSpecies))\n    sppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n        movement, param, native)\n    rel = Gauss{typeof(first(opts))}()\n    eco = Ecosystem(sppl, abenv, rel)\n    simulate!(eco, times, timestep)\n    endabuns[i] = sum(eco.abundances.matrix)\nend\n\nbar!(string.(areas), endabuns, grid = false, xlab = \"Area (km²)\",\nylab = \"Total abundance\", guidefontsize = 16,\ntickfontsize= 16, titlefontsize=24, margin = 10.0*Plots.mm,\nlabel = \"\", subplot = 3, title = \"C\", titleloc = :left,\nleft_margin = 20.0 *Plots.mm)\n\n## Sustain large number of species ##\ntimes = 10years; timestep = 1month\nlensim = length(0month:timestep:times)\nreps = 10\nspecies = [100, 500, 1_000, 5_000]\nSR = zeros(Float64, length(species), reps)\nfor r in 1:reps\n    for i in eachindex(species)\n        numSpecies = species[i]; grd = (10,10); req=(450000.0kJ/m^2, 192.0nm/m^2);\n        individuals = 100_000_000; area = 100.0km^2;\n        totalK = (4.5e11kJ/km^2, 192.0mm/km^2)\n\n        abenv1 = simplehabitatAE(298.0K, grd, totalK[1], area)\n        abenv2 = simplehabitatAE(298.0K, grd, totalK[2], area)\n        bud = BudgetCollection2(abenv1.budget, abenv2.budget)\n        abenv = GridAbioticEnv{typeof(abenv1.habitat), typeof(bud)}(abenv1.habitat, abenv1.active, bud, abenv1.names)\n\n        vars = rand(Uniform(1.0, 5.0), numSpecies) .* K\n        opts = 298.0K .+ vars .* range(-3, stop = 3, length = numSpecies)\n        av_dist = rand(Uniform(0.6, 2.4), numSpecies) .* km\n        kernel = GaussianKernel.(av_dist, 10e-10)\n\n        death = abs.(rand(Normal(0.15, 0.135), numSpecies)) ./year\n        birth = death\n        l = 1.0\n        s = 0.1\n        boost = 1.0\n\n        size_mean = rand(Normal(1.0, 0.5), numSpecies) .* m^2\n        # Set up how much energy each species consumes\n        energy_vec1 = SolarRequirement(abs.(req[1] .* size_mean))\n        energy_vec2 = WaterRequirement(abs.(req[2] .* size_mean))\n\n        energy_vec = ReqCollection2(energy_vec1, energy_vec2)\n        param = PopGrowth{typeof(unit(birth[1]))}(birth, death, l, s , boost)\n\n        # Create ecosystem\n\n        movement = BirthOnlyMovement(kernel, NoBoundary())\n\n        traits = GaussTrait(opts, vars)\n        native = fill(true, numSpecies)\n        abun = rand(Multinomial(individuals, numSpecies))\n        sppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n            movement, param, native)\n        rel = Gauss{typeof(first(opts))}()\n        eco = Ecosystem(sppl, abenv, rel)\n        simulate!(eco, times, timestep)\n        SR[i, r] = sum(sum(eco.abundances.matrix, dims = 2) .> 0)\n        print(\".\")\n    end\nend\n\nmeanSR = dropdims(mean(SR, dims = 2), dims = 2)\nsdSR = dropdims(std(SR, dims = 2), dims = 2)\n\nbar!(string.(species), meanSR ./species, yerr= sdSR ./ species, grid = false, xlab = \"Number of species introduced\",\nylab = \"% Species survived\", guidefontsize = 16,\ntickfontsize= 16, titlefontsize=24, margin = 10.0*Plots.mm,\nlabel = \"\",  title = \"D\", subplot = 4, titleloc = :left,\nleft_margin = 20.0 *Plots.mm, ylim = (0, 1))","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) Model testing on island ecosystems. (A) Total abundance of 100 species, with varying resources of water and solar energy across the grid. (B) Total abundance of 100 species, with increasing area size. (C) Total abundance of 100 species, with increasing grid square resolution. (D) Percentage of species survived after 10 years of simulation.","category":"page"},{"location":"examples/#.-Dispersal","page":"Examples","title":"3. Dispersal","text":"","category":"section"},{"location":"examples/","page":"Examples","title":"Examples","text":"Finally, we verify that dispersal is functioning as expected. This figure shows the overall abundance of an island populated with two species at opposite extremes of the ecosystem after ten years of simulation. The species moved faster and further into the unpopulated island centre when they had higher average dispersal distances, though again with some edge effects.","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"times = 50years; timestep = 1month\nlensim = length(0month:timestep:times)\ndistances = [0.5, 1.0, 2.0, 4.0]\nendabuns = zeros(Int64, 10, 10, length(distances))\nfor i in eachindex(distances)\n    numSpecies = 2; grd = (10,10); req=(450000.0kJ/m^2, 192.0nm/m^2);\n    individuals = 0; area = 100.0km^2;\n    totalK = (4.5e11kJ/km^2, 192.0mm/km^2)\n\n    abenv1 = simplehabitatAE(298.0K, grd, totalK[1], area)\n    abenv2 = simplehabitatAE(298.0K, grd, totalK[2], area)\n    bud = BudgetCollection2(abenv1.budget, abenv2.budget)\n    abenv = GridAbioticEnv{typeof(abenv1.habitat), typeof(bud)}(abenv1.habitat, abenv1.active, bud, abenv1.names)\n\n    vars = fill(2.0, numSpecies) .* K\n    opts = fill(298.0, numSpecies) .* K\n    av_dist = fill(distances[i], numSpecies) .* km\n    kernel = GaussianKernel.(av_dist, 10e-10)\n\n    death = 0.15/ year\n    birth = death\n    l = 1.0\n    s = 0.1\n    boost = 1.0\n\n    size_mean = 1.0m^2\n    # Set up how much energy each species consumes\n    energy_vec1 = SolarRequirement(fill(req[1] * size_mean, numSpecies))\n    energy_vec2 = WaterRequirement(fill(req[2] * size_mean, numSpecies))\n\n    energy_vec = ReqCollection2(energy_vec1, energy_vec2)\n    param = EqualPop(birth, death, l, s , boost)\n\n    # Create ecosystem\n\n    movement = BirthOnlyMovement(kernel, NoBoundary())\n\n    traits = GaussTrait(opts, vars)\n    native = fill(true, numSpecies)\n    abun = rand(Multinomial(individuals, numSpecies))\n    sppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n        movement, param, native)\n    rel = Gauss{typeof(first(opts))}()\n    eco = Ecosystem(sppl, abenv, rel)\n    eco.abundances.grid[1, :, 1] .= 100.0\n    eco.abundances.grid[2, :, 10] .= 100.0\n    simulate!(eco, times, timestep)\n    endabuns[:, :, i] = sum(eco.abundances.matrix, dims = 1)\nend\n\nheatmap(grid = false, xlab = \"Distance (km)\",\nylab = \"Distance (km)\", size = (1200, 800),\nguidefontsize = 12,tickfontsize= 12, titlefontsize=18,\nmargin = 10.0*Plots.mm, legendfontsize = 12, label = \"\",\nlayout = (@layout [a b; c d]), link = :both)\ntitles = [\"A\", \"B\", \"C\", \"D\"]\nfor i in 1:4\n    m = distances[i]\n    display(heatmap!(1:10,1:10, endabuns[:, :, i],\n    grid = false, xlab = \"Distance (km)\", ylab = \"Distance (km)\",\n    guidefontsize = 16, tickfontsize= 16,\n    titlefontsize=24, title = titles[i], margin = 10.0*Plots.mm,\n    label = \"\", subplot = i, titleloc = :left,\n    clim = (0, 1.5e4), link = :both))\nend","category":"page"},{"location":"examples/","page":"Examples","title":"Examples","text":"(Image: ) Total abundance of two species in island ecosystems after 10 years of simulation, with species populated at opposite sides of the island. Those with higher dispersal distances moved further away from their starting populations at a faster rate. (A) Mean dispersal distance of 0.5km, (B) mean dispersal distance of 1km, (C) Mean dispersal distance of 2km, Mean dispersal distance of 4km.","category":"page"},{"location":"basics/#The-basics-of-EcoSISTEM.jl","page":"Basics","title":"The basics of EcoSISTEM.jl","text":"","category":"section"},{"location":"basics/#Install","page":"Basics","title":"Install","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"]add EcoSISTEM","category":"page"},{"location":"basics/#Setting-up-an-ecosystem","page":"Basics","title":"Setting up an ecosystem","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"The package runs on an Ecosystem containing information about species, the SpeciesList, their environment, AbioticEnvironment and the relationship between the two, TraitRelationship.","category":"page"},{"location":"basics/#A-simple-example","page":"Basics","title":"A simple example","text":"","category":"section"},{"location":"basics/","page":"Basics","title":"Basics","text":"Load required packages","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"using EcoSISTEM\nusing EcoSISTEM.Units\nusing Unitful, Unitful.DefaultSymbols\nusing Distributions\nusing Diversity","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Set up initial parameters for ecosystem","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"numSpecies = 10; grid = (5, 5); req= 10.0kJ; individuals=1000; area = 1000.0*km^2; totalK = 1.0kJ/km^2","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Set up how much energy each species consumes","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"energy_vec = SolarRequirement(fill(req, numSpecies))","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Set rates for birth and death","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"birth = 0.6/year\ndeath = 0.6/year\nlongevity = 1.0\nsurvival = 0.2\nboost = 1.0\n# Collect model parameters together\nparam = EqualPop(birth, death, longevity, survival, boost)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Create kernel for movement","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"kernel = fill(GaussianKernel(10.0km, 10e-10), numSpecies)\nmovement = BirthOnlyMovement(kernel, Torus())","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Create species list, including their temperature preferences, seed abundance and native status","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"opts = fill(274.0K, numSpecies)\nvars = fill(0.5K, numSpecies)\ntraits = GaussTrait(opts, vars)\nnative = fill(true, numSpecies)\n# abun = rand(Multinomial(individuals, numSpecies))\nabun = fill(div(individuals, numSpecies), numSpecies)\nsppl = SpeciesList(numSpecies, traits, abun, energy_vec,\n    movement, param, native)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Create abiotic environment - even grid of one temperature","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"abenv = simplehabitatAE(274.0K, grid, totalK, area)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Set relationship between species and environment (gaussian)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"rel = Gauss{typeof(1.0K)}()","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Create ecosystem","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"eco = Ecosystem(sppl, abenv, rel)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Run simulation","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"# EcoSISTEM Parameters\nburnin = 5years; times = 50years; timestep = 1month; record_interval = 3months; repeats = 1\nlensim = length(0years:record_interval:times)\n# Burnin\n@time simulate!(eco, burnin, timestep)","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"Plot using SpatialEcology","category":"page"},{"location":"basics/","page":"Basics","title":"Basics","text":"using SpatialEcology\nplot(eco)","category":"page"},{"location":"#EcoSISTEM.jl","page":"Home","title":"EcoSISTEM.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"EcoSISTEM is a Julia package that provides functionality for simulating species undergoing dynamic biological processes such as birth, death, competition and dispersal, as well as environmental changes in climate and habitat.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The package was primarily developed for global scale simulations of plant biodiversity. The underlying model for this is described in the arXiv paper arXiv:1911.12257 (q-bio.QM) Dynamic virtual ecosystems as a tool for detecting large-scale responses of biodiversity to environmental and land-use change.","category":"page"},{"location":"","page":"Home","title":"Home","text":"There are substantial changes to the package introduced through the dev branch (docs), including epidemiological simulations and refactoring of the code base for further flexibility.","category":"page"},{"location":"","page":"Home","title":"Home","text":"This package is in beta now, so please raise an issue if you find any problems. For more information on how to contribute, please read our contributing guidelines.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: )","category":"page"},{"location":"simulation-jl/","page":"-","title":"-","text":"Table of datasets currently in use by EcoSISTEM.jl","category":"page"},{"location":"simulation-jl/","page":"-","title":"-","text":"Preliminary list of parameters/datasets.","category":"page"},{"location":"simulation-jl/","page":"-","title":"-","text":"Name of parameter/ dataset Description Value Source Other info (e.g. stability)\np_s Probability of developing symptoms 0.96 http://gabgoh.github.io/COVID/index.html (From Thibaud's original model) \np_h Probability of hospitalisation 0.2 Guess \ncfr_home Case fatality ratio (at home) 0.1 Guess \ncfr_hospital Case fatality ratio (at hospital) 0.1 Guess \nT_lat Latent period 5 days http://gabgoh.github.io/COVID/index.html (From Thibaud's original model) \nT_asym Asymptomatic period 3 days http://gabgoh.github.io/COVID/index.html (From Thibaud's original model) \nT_sym Symptomatic period 5 days http://gabgoh.github.io/COVID/index.html (From Thibaud's original model) \nT_hosp Hospitalisation period 5 days https://www.icnarc.org/Our-Audit/Audits/Cmp/Reports (From Thibaud's original model) \nT_rec Recovery period 11 days http://gabgoh.github.io/COVID/index.html (From Thibaud's original model) \nmu_1 Probability of becoming Asymptomatic 1/T_lat  \nmu_2 Probability of becoming Symptomatic ps * 1/Tasym  \nhospitalisation Probability of becoming Hospitalised ph * 1/Tsym  \nsigma_1 Probability of Recovery from Asymptomatic (1 - ps) * 1/Tasym  \nsigma_2 Probability of Recovery from Symptomatic (1 - ph) * (1 - cfrhome) * 1/T_rec  \nsigma_hospital Probability of Recovery from Hospital (1 - cfrhosp) * 1/Thosp  \ndeath_home Probability of Death at home cfrhome * 2/Thosp  \ndeath_hospital Probability of Death at hospital cfrhosp * 1/Thosp  \nScotlandDensity2011 Scottish population density at 1km grid  UK census 2011 - A Reeves 'Covid19-ScottishCensusData' repo \ndispersal_dist Average dispersal distance of virus per disease category 2.0km per infectious disease category Guess Varies depending on grid size\nmean_pref Mean temperature preference of virus 298K Guess Currently tuned to fit environment perfectly\nvar_pref Temperature niche width of virus 0.1K Guess Currently tuned to fit environment perfectly\nbirth Probability of giving birth per individual 1.3e-4/day (20-40 year olds), 0 otherwise Guess \ndeath Probability of giving natural mortality per individual 2.7e-5/day Guess \nvirusgrowthasymp Rate of generating virus per asymptomatic individual 0.1/day Guess \nvirusgrowthsymp Rate of generating virus per symptomatic individual 0.1/day Guess \nbeta_force Force of infection 10.0/day Guess \nbeta_env Environmental transmission 10.0/day Guess ","category":"page"}]
}
